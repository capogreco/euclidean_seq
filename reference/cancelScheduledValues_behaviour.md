Analyzing AudioParam.cancelScheduledValues() for Portamento Effects in Web Audio APIThe implementation of seamless, glitch-free portamento (pitch gliding) for continuous sounds presents a common challenge in Web Audio API development. This typically involves interrupting any ongoing frequency changes and initiating a new glide to a target frequency. Achieving this requires a precise understanding and sequencing of AudioParam automation commands. This report provides a detailed analysis of the audioParam.cancelScheduledValues() method, its interaction with audioParam.setValueAtTime(), audioParam.exponentialRampToValueAtTime(), and the AudioParam.value property, particularly in the context of creating portamento effects. The discussion will address specific code sequences and potential cross-browser considerations.1. IntroductionManipulating AudioParam objects, which control individual aspects of an AudioNode like frequency or gain 1, is fundamental to dynamic audio processing in the Web Audio API. For effects such as portamento, where a parameter like an oscillator's frequency needs to smoothly transition from its current state to a new target value, developers must carefully schedule changes to the AudioParam's timeline. The core methods involved in such operations often include cancelScheduledValues() to clear previous automations, setValueAtTime() to establish an immediate value, and a ramping method like exponentialRampToValueAtTime() to create the glide.The interaction between these methods, especially concerning the exact timing specified by AudioContext.currentTime and the interpretation of an AudioParam's current value, can lead to subtle issues. These issues can manifest as audible artifacts or unexpected behavior if not handled correctly. This report will dissect the mechanics of these AudioParam methods, evaluate two common JavaScript sequences for initiating portamento, and discuss nuances related to browser implementations. The goal is to provide a clear understanding that supports the development of robust and predictable audio behavior in interactive applications.2. Core Concepts: AudioParam Automation and Event CancellationUnderstanding how AudioParam automations are scheduled and cancelled is crucial before analyzing specific portamento implementations.2.1. The AudioParam Timeline and Event ProcessingEach AudioParam maintains an internal, time-ordered list of automation events. These events are scheduled by methods such as setValueAtTime(), linearRampToValueAtTime(), exponentialRampToValueAtTime(), setValueCurveAtTime(), and setTargetAtTime().2 The Web Audio API processes this list of events to compute the parameter's actual value at any given moment in time. This computation typically occurs on a per-render-quantum basis.4 A render quantum is a small block of audio samples (e.g., 128 sample-frames by default) that the audio engine processes together.5Automation methods schedule changes that are set to take effect at specific times, measured in seconds relative to the AudioContext.currentTime at the moment the context was created.3 The AudioContext.currentTime property provides the current time of the audio processing clock.The W3C Web Audio API specification details how events scheduled for the exact same time are handled. Generally, events are applied in the order they were called by the application code. However, cancellation methods like cancelScheduledValues() have specific rules that override or remove previously scheduled events from the timeline. The order of API calls is therefore of paramount importance, especially when multiple events are scheduled for, or affect, the same point in time on the AudioParam's timeline. This timeline model is fundamental to understanding what is being modified when cancellation methods are invoked.2.2. AudioParam.cancelScheduledValues(cancelTime)The cancelScheduledValues() method is a core tool for managing AudioParam automations.

Purpose: Its primary function is to remove all automation events scheduled for an AudioParam that would occur at or after the specified cancelTime.2 This allows developers to interrupt planned changes and redefine the parameter's future behavior.


Parameter cancelTime: This is a double-precision floating-point number representing the time, in seconds, from which the cancellation should take effect. This time is relative to the AudioContext's timeline (i.e., the same reference as AudioContext.currentTime).2


Impact on Value at cancelTime: If an automation event (e.g., a setValueAtTime() call or the start of a ramp) was scheduled to occur precisely at cancelTime, cancelScheduledValues(cancelTime) will remove that event from the timeline.8


Impact on Value after cancelTime: Once events at and after cancelTime are removed, the AudioParam's value will be determined by any automations that were scheduled before cancelTime and are still active or have set the value. For example, if a ramp started before cancelTime and was scheduled to end before cancelTime, the parameter would hold the ramp's final value. If a ramp started before cancelTime and was scheduled to continue through cancelTime, its segment from cancelTime onwards is removed. The value at cancelTime (and holding steady thereafter, if no new automations are added) would be the value the ramp had reached just before cancelTime. If no automation events prior to cancelTime dictate the value, it might revert to its defaultValue or the last explicitly set value.1 cancelScheduledValues() does not, by itself, set or "hold" a specific value at cancelTime. It merely clears the path for subsequent automations or reveals the state dictated by prior, uncancelled events.


Return Value: The method typically returns a reference to the AudioParam object itself.2 Some older browser implementations of other AudioParam methods have been noted to return undefined 9, so while cancelScheduledValues is generally expected to return the AudioParam, awareness of potential past variations is useful.

The critical aspect to grasp is that cancelScheduledValues() doesn't introduce a new value; it modifies the existing timeline of scheduled events. The value of the parameter immediately after this call (at cancelTime) is whatever results from the automations that remain on the timeline up to that point.2.3. AudioParam.cancelAndHoldAtTime(cancelTime)Another method related to cancelling automations is cancelAndHoldAtTime().

Purpose: This method also cancels all scheduled future changes to the AudioParam from cancelTime onwards, much like cancelScheduledValues().10


Key Difference: The crucial distinction is that cancelAndHoldAtTime() explicitly holds the AudioParam's value at whatever value it would have computed at the specified cancelTime. This value then remains constant until further automation methods are called to change it.10


Parameter cancelTime: This parameter functions identically to that in cancelScheduledValues().


Browser Availability: This method has "Limited availability" and is "not Baseline because it does not work in some of the most widely-used browsers".10 This significantly restricts its practical use in cross-browser applications.

Conceptually, cancelAndHoldAtTime() provides a cleaner way to interrupt an ongoing automation and freeze the parameter's value at that exact point. Its limited availability, however, often necessitates the use of more complex sequences involving cancelScheduledValues() and setValueAtTime() to achieve a similar, albeit potentially less precise, outcome.Table 1: Comparison of cancelScheduledValues() and cancelAndHoldAtTime()
FeaturecancelScheduledValues(t)cancelAndHoldAtTime(t)Cancels events scheduled at time t?YesYesCancels events scheduled after time t?YesYesValue at time t after call?Determined by events scheduled before t that are still in effect, or the value of a ramp that completed before t.The value the parameter would have had at time t is computed and then held constant.Value after time t (if no new events)?Continues based on events prior to t (e.g., holds the value from just before t if a ramp was interrupted).Remains held at the value computed for time t.Baseline Browser Availability?Yes 2No 10
This table highlights the fundamental differences, particularly in how the parameter's value is treated at and after the cancelTime.3. Understanding AudioParam.value and AudioContext.currentTimeThe AudioParam.value property and the AudioContext.currentTime are central to scheduling and interacting with AudioParam automations. Their precise meanings and interplay are critical.3.1. The AudioParam.value GetterWhen reading the value property of an AudioParam (e.g., freqParam.value):
It returns the parameter's "intrinsic value" for the current time 11, or more practically, its value as of the audio rendering engine's "most recent render quantum".4
A "render quantum" is a block of sample-frames that the audio engine processes as a unit.5 This means that AudioParam.value reflects a state that has just been computed by the audio rendering thread. Consequently, this value is slightly in the past relative to the execution of JavaScript on the main thread and the value of AudioContext.currentTime (which looks towards the next quantum). This "slightly stale" nature of the returned value is a key factor in understanding potential discontinuities.
The Web Audio API specification notes that the internal data type for AudioParam values is often a single-precision (32-bit) floating-point number, whereas JavaScript uses 64-bit double-precision floats. This can lead to minute precision differences when setting and then immediately getting a value, though this is usually a minor concern compared to timing issues.4
3.2. The AudioParam.value SetterWhen setting the value property of an AudioParam (e.g., freqParam.value = 0.5):
This action is strictly equivalent to calling AudioParam.setValueAtTime(X, audioCtx.currentTime), where X is the value being assigned.4
This means that setting .value schedules an instantaneous change to the new value X at the current audio context time. It is not a mechanism that bypasses the automation timeline but rather a shorthand for a specific type of timeline event.
Historically, there were inconsistencies in this behavior. For example, Mozilla fixed an issue in Firefox 134 (Bug 1308435) where setting .value might have been silently ignored if an automation was active on the parameter at that time.13 The resolution of such bugs indicates a convergence among browsers towards the specified equivalence with setValueAtTime().
3.3. AudioContext.currentTimeThe AudioContext.currentTime property:
Represents an ever-increasing hardware time in seconds, starting from 0 when the AudioContext is created.5 It serves as the master clock for all audio scheduling within that context.
More specifically, the specification describes it as "the time in seconds of the sample frame immediately following the last sample-frame in the block of audio most recently processed by the context's rendering graph".12
This definition implies that currentTime points to the beginning of the next audio processing block. It is the "present" moment from the perspective of scheduling new audio events that should take effect as soon as possible. It is not the time of the audio that is currently being heard (which corresponds to a slightly earlier moment).
3.4. Critical Implications of setValueAtTime(param.value, now) for Interrupting RampsThe interaction between the AudioParam.value getter and AudioContext.currentTime has significant implications when attempting to interrupt an ongoing ramp and start a new one from the "current" value. Consider the common pattern param.setValueAtTime(param.value, now), where now is audioCtx.currentTime:
When param.value is read, it returns the computed value of the parameter from the last completed render quantum (as detailed in Section 3.1). Let this be value_at_T_past.
AudioContext.currentTime (now) represents the time at the beginning of the next render quantum (say, T_current). T_current will be slightly later than T_past.
The call param.setValueAtTime(value_at_T_past, T_current) schedules an instantaneous change to value_at_T_past to occur at time T_current.
If the AudioParam was in the middle of a smooth ramp, its true value at T_current (had it not been interrupted) would likely be different from value_at_T_past. By forcing the parameter to value_at_T_past at T_current, a small jump or discontinuity can occur. The ramp is effectively truncated, and its value is pinned to a slightly older state before a new ramp begins.This issue is highlighted in discussions surrounding the Web Audio API specification. For instance, it has been noted that "Chrome's AudioParam.value returns something close to the automation value, but far enough that doing AudioParam.setValueAtTime(AudioParam.value, AudioContext.currentTime); in the middle of a ramp will cause discontinuity artifacts." The same source elaborates: "it is impossible to avoid discontinuity from AudioParam.setValueAtTime(AudioParam.value, AudioContext.currentTime). The definition of currentTime... is a time position in the past [referring to the end of the last processed block]. Similarly, the value you get from AudioParam.value is also a computed value in the past. So when you schedule a data point with values from the past, there will be a conflict with ongoing automation in the rendering thread".12 This "conflict" is the source of the discontinuity.4. Analysis of Portamento Code Sequences for freqParamGiven the foundational concepts, the two JavaScript sequences provided for implementing portamento on a frequency parameter (freqParam) can now be analyzed. It is assumed that now is a variable holding audioCtx.currentTime, and the objective is to smoothly transition the frequency to a new target value freq using an exponential ramp over ramp_time seconds.4.1. Sequence 1:JavaScriptfreqParam.cancelScheduledValues(now);
freqParam.setValueAtTime(freqParam.value, now); // Reads freqParam.value AFTER cancellations for >= now
freqParam.exponentialRampToValueAtTime(freq, now + ramp_time);
Step-by-Step Execution Analysis:

freqParam.cancelScheduledValues(now);

Action: All automation events previously scheduled for freqParam that were to occur at or after time now are removed from its event timeline. If freqParam was in the middle of a ramp intended to continue past now, the future portion of that ramp is cancelled. Any setValueAtTime, linearRampToValueAtTime, etc., events scheduled at or after now are also removed.
State of freqParam: The intrinsic value of freqParam is now determined by any automations that were scheduled before now and are still in effect (e.g., the current point of a ramp that started before now and was meant to end before now, or a setValueAtTime that occurred before now). If no such prior automations define its state up to now, it might hold its defaultValue or the last explicitly set value that occurred before now.



freqParam.setValueAtTime(freqParam.value, now);

Action: This line reads the current freqParam.value. Critically, this read occurs after cancelScheduledValues(now) has conceptually cleared future automations. Therefore, the freqParam.value obtained here reflects the parameter's state resulting from automations prior to now. As discussed in Sections 3.1 and 3.4, this value (value_at_last_quantum) is based on the last render quantum, so it's a snapshot from a time slightly before now.
An event is then scheduled: freqParam will take this value_at_last_quantum instantaneously at time now.
Potential Discontinuity: If freqParam was in the middle of a ramp that was active up to now (before being cancelled from now onwards by the previous line), value_at_last_quantum might not perfectly align with what the ramp's value would have been precisely at now. This setValueAtTime call effectively "flattens" or "pins" the parameter's value at now to this value_at_last_quantum. This is where the micro-discontinuity identified in 12 can occur.



freqParam.exponentialRampToValueAtTime(freq, now + ramp_time);

Action: An exponential ramp is scheduled to start at time now and end at time now + ramp_time.
Starting Point: According to the Web Audio API specification, ramps start from the value established by the immediately preceding automation event on the timeline.3 In this sequence, the preceding event is the setValueAtTime(value_at_last_quantum, now) call. Thus, the new exponential ramp will begin its glide from value_at_last_quantum at time now.
Behavior: The frequency will glide exponentially from value_at_last_quantum (at time now) towards the target freq (to be reached at time now + ramp_time).


This sequence provides a controlled start for the new ramp, explicitly defining its initial value based on a (slightly historic) reading of freqParam.value. The primary trade-off is the potential for a minor audible discontinuity if the pinned value differs from the parameter's natural trajectory at now.4.2. Sequence 2:JavaScriptfreqParam.setValueAtTime(freqParam.value, now);
freqParam.cancelScheduledValues(now);
freqParam.exponentialRampToValueAtTime(freq, now + ramp_time);
Step-by-Step Execution Analysis:

freqParam.setValueAtTime(freqParam.value, now);

Action: This line reads freqParam.value. At this point, no cancellations for time now have occurred yet in this sequence. So, freqParam.value reflects the parameter's state based on its entire existing timeline up to the last render quantum (value_at_last_quantum).
An event is scheduled: freqParam is to take the value value_at_last_quantum instantaneously at time now. This event is added to freqParam's internal list of automation events.



freqParam.cancelScheduledValues(now);

Action: All automation events on freqParam scheduled to occur at or after time now are removed from its event timeline. Crucially, this includes the setValueAtTime(value_at_last_quantum, now) event that was just scheduled in the immediately preceding line of code. Since that setValueAtTime event was scheduled for time now, cancelScheduledValues(now) will remove it.
State of freqParam: The intrinsic value of freqParam is now determined by automations that were scheduled before now AND were not the setValueAtTime event from step 1 of this sequence (as it has been cancelled). If freqParam was in the middle of a ramp that started before now (and was unrelated to the just-cancelled setValueAtTime), its value will be that ramp's value as it approaches now.



freqParam.exponentialRampToValueAtTime(freq, now + ramp_time);

Action: An exponential ramp is scheduled to start at time now.
Starting Point: The ramp will start from the value established by the last effective automation event prior to or at now. Since the setValueAtTime(value_at_last_quantum, now) from step 1 of this sequence was cancelled by step 2, it has no effect on the timeline. Therefore, the new ramp will start from whatever value freqParam had due to automations that were scheduled before the setValueAtTime in step 1 and were not themselves cancelled. This could be an entirely unintended value if, for example, a different ramp was already in progress and was meant to define the value at now.
Behavior: The frequency will glide from this potentially unexpected (and likely "older") value towards freq.


Sequence 2 is fundamentally flawed for the purpose of starting a new ramp from the perceived current value. The cancelScheduledValues(now) call negates the intended effect of the immediately preceding setValueAtTime(freqParam.value, now). The intended anchor point for the new ramp is scheduled and then immediately destroyed before the ramp itself is scheduled.4.3. Determining the Correct SequenceSequence 1 is the more correct and standard approach for interrupting an AudioParam's automation and starting a new one from approximately its current value.

Justification for Sequence 1:

freqParam.cancelScheduledValues(now); clears any conflicting future automations.
freqParam.setValueAtTime(freqParam.value, now); then attempts to "pin" the parameter's value at now to its most recently computed state (freqParam.value). This explicitly sets the starting point for the subsequent ramp.
freqParam.exponentialRampToValueAtTime(freq, now + ramp_time); starts the new ramp from this pinned value.
This sequence provides a controlled, albeit potentially slightly imperfect (due to freqParam.value timing), transition. An example of a similar pattern (cancelScheduledValues(t0); setValueAtTime(0, t0); linearRampToValueAtTime(1, t1);) can be found in community discussions and libraries, indicating its accepted use.14



Why Sequence 2 is Incorrect:The cancelScheduledValues(now) call in Sequence 2 nullifies the setValueAtTime(freqParam.value, now) call made immediately before it. This is because cancelScheduledValues(T) removes events scheduled at time T as well as those after T.8 As a result, the new exponentialRampToValueAtTime will not start from the intended freqParam.value (as read at the beginning of the sequence). Instead, it will start from whatever value the AudioParam had due to automations that were active before the (now cancelled) setValueAtTime event. This is highly likely to cause an audible jump to an older or unexpected value before the new portamento glide begins, which is contrary to the goal of a smooth transition.

The user's intent with setValueAtTime(freqParam.value, now) is to capture the current state as the starting point for the new ramp. Sequence 1, despite the known timing nuance of param.value, largely achieves this intent by its operational mechanics. Sequence 2 fails because the mechanics of cancelScheduledValues counteract the user's immediate prior action.Table 2: Step-by-Step Timeline Analysis of Portamento Code Sequences(Assuming now = audioCtx.currentTime, V_initial is the value of freqParam due to events before this sequence, and V_q is the result of freqParam.value read at a given step, representing value at last render quantum.)SequenceLine of CodeAction Description (W3C Semantics)freqParam Value Immediately Before Line (Intrinsic, based on prior events)Key Scheduled Events on Timeline After Line (relevant to now and later)Effect on Ramp Start1freqParam.cancelScheduledValues(now);Removes all events from timeline at or after now.V_initial (or value of ongoing ramp just before now)(Timeline is clear from now onwards)Clears path for new ramp.1freqParam.setValueAtTime(freqParam.value, now);Reads freqParam.value (let this be V_q1, reflecting state after above cancel but before this setValueAtTime takes effect). Schedules [setValue, V_q1, now].V_q1 (determined by events < now)[setValue, V_q1, now]Pins ramp start to V_q1.1freqParam.exponentialRampToValueAtTime(freq, now + ramp_time);Schedules `` starting from value at now.V_q1 (due to previous setValueAtTime)[setValue, V_q1, now], ``Ramp starts from V_q1 at now. Correct.2freqParam.setValueAtTime(freqParam.value, now);Reads freqParam.value (let this be V_q2, reflecting state before any actions in this sequence). Schedules [setValue, V_q2, now].V_initial (or value of ongoing ramp just before now)(Potentially existing events for >= now), [setValue, V_q2, now]Temporarily schedules V_q2 at now.2freqParam.cancelScheduledValues(now);Removes all events from timeline at or after now. This includes the [setValue, V_q2, now] event just added.V_initial (or value of ongoing ramp just before now, as the setValueAtTime is about to be cancelled)(Timeline is clear from now onwards, original setValueAtTime is gone)Removes intended ramp start.2freqParam.exponentialRampToValueAtTime(freq, now + ramp_time);Schedules `` starting from value at now.Value determined by events < now (i.e., V_initial or similar, not V_q2).``Ramp starts from V_initial (or similar) at now. Incorrect.This table illustrates how Sequence 1 correctly establishes a starting point for the ramp, whereas Sequence 2 inadvertently cancels its own attempt to set that starting point.5. Browser Implementation Nuances and Cross-Browser CompatibilityConcerns about differing implementations between browsers like Chrome, Firefox, and Safari are valid, given the historical evolution of the Web Audio API.5.1. AudioParam.value Getter/Setter BehaviorThe W3C specification aims for consistent behavior of AudioParam.value, but the path to current implementations has seen some variations.
A GitHub issue from 2018 regarding the Web Audio API specification 12 highlighted discussions where Chrome's AudioParam.value getter was noted to return a value that, while close to the automation value, could lead to discontinuities when used in setValueAtTime(AudioParam.value, AudioContext.currentTime). The same discussion mentioned an intent by a Gecko (Firefox) developer not to implement a particular interpretation of .value due to perceived inconsistencies, suggesting past divergences in approach or understanding.
Current MDN documentation 4 and interpretations of the W3C specification 12 assert that setting AudioParam.value = X is equivalent to AudioParam.setValueAtTime(X, audioCtx.currentTime).
A significant step towards consistency was the fix in Firefox 134 for Bug 1308435.13 The release note states: "AudioParam.value now allows the value to be set even during the time that an automated event is scheduled: previously the operation would silently be ignored at those times." This aligns Firefox's behavior more closely with the specification and the generally more permissive behavior previously observed in Chrome in this respect.
The primary remaining concern for developers is often the timing nuance of the AudioParam.value getter reflecting the state of the last render quantum.4 This behavior appears to be a consequence of the API's operational model as defined in the specification. Therefore, the micro-discontinuity discussed in Section 3.4 is more likely a result of this fundamental API design rather than a current, widespread browser-specific bug in the getter/setter mechanism itself. Modern browsers are largely converging on the specified behavior for the .value property.5.2. cancelScheduledValues() and Event TimingThe core functionality of cancelScheduledValues(cancelTime)—which is to cancel automation events occurring at or after cancelTime—is a fundamental aspect of AudioParam control. This behavior is expected to be consistent across browsers that adhere to the W3C Web Audio API specification.2 The provided research material does not indicate current, major cross-browser inconsistencies specifically for cancelScheduledValues() itself, assuming the cancelTime parameter is correctly interpreted relative to AudioContext.currentTime.Subtle differences could theoretically arise if browsers had divergent internal implementations of event list management or the precise timing of event processing at the exact cancelTime. However, the W3C specification aims to define these behaviors sufficiently to prevent such discrepancies.85.3. Implications for SafariThe provided research snippets do not contain specific, current information detailing unique deviations in Safari's WebKit engine concerning cancelScheduledValues() or its interaction with AudioParam.value in the context of the portamento scenario.Generally, Web Audio API support in Safari is comprehensive. Historically, Safari has sometimes lagged slightly behind Chrome or Firefox in adopting the very latest specification changes or has occasionally exhibited unique bugs, but it aims to implement W3C standards. Basic ramp functionality, such as linearRampToValueAtTime, has long been supported in iOS WebViews (a WebKit environment).9Given the absence of specific data pointing to Safari-related issues for this exact interaction, the most prudent approach is to assume compliance with the W3C specification but to conduct thorough testing in Safari for any critical audio application. The principles regarding the timing of AudioParam.value and the effects of cancelScheduledValues() are based on these specifications.5.4. Strategies for Robust CodeTo write robust Web Audio code that behaves predictably across browsers:
Adhere to W3C Specifications: Base implementations on patterns that are well-aligned with the official W3C Web Audio API specification.
Acknowledge AudioParam.value Nuances: Be consciously aware of the AudioParam.value getter's timing characteristics (reflecting the last render quantum). Design automation sequences accordingly. For instance, accept the potential for micro-discontinuities when using Sequence 1, or investigate more complex solutions if absolute, sample-perfect smoothness is paramount and cancelAndHoldAtTime() is not a viable option due to its limited availability.
Consistent Time References: Use audioCtx.currentTime consistently. For a sequence of operations intended to be atomic, fetch audioCtx.currentTime once at the beginning and use that stored variable for all time parameters within that sequence. This avoids slight drifts that could occur from multiple calls to audioCtx.currentTime.
Cross-Browser Testing: Always test critical audio behavior across all target browsers, including Chrome, Firefox, and Safari.
Consult Reliable Documentation: Refer to resources like MDN Web Docs 2 and the W3C specifications for canonical descriptions of API behavior. MDN's best practices, for example, advise using AudioParam methods for scheduling when timing is critical.15
6. Recommendations for Implementing PortamentoBased on the analysis, the following recommendations are provided for implementing portamento effects.6.1. The Definitive Recommended Sequence (Variant of Sequence 1)Sequence 1, as analyzed, is the functionally correct and most robust approach for the user's portamento scenario, given current widespread browser support:JavaScript// let now = audioCtx.currentTime; // Obtain current time once
// let currentFreq = freqParam.value; // Optional: Read BEFORE cancel if needed for other logic,
                                   // but be aware this value might not be the exact start of the new ramp.

freqParam.cancelScheduledValues(now);

// The freqParam.value read by setValueAtTime below is the intrinsic value
// of the parameter AFTER cancellations for time >= 'now' have taken effect
// for the purpose of this read, and BEFORE this setValueAtTime itself is applied
// to the timeline for future calculations.
freqParam.setValueAtTime(freqParam.value, now);

freqParam.exponentialRampToValueAtTime(freq, now + ramp_time);
Explanation of freqParam.value in setValueAtTime:When freqParam.setValueAtTime(freqParam.value, now) is called, the freqParam.value on the right-hand side is read at that moment. This read accesses the AudioParam's current intrinsic value, which, due to the preceding cancelScheduledValues(now), reflects the outcome of any automations that occurred prior to now. This value is then used to schedule an instantaneous change at now, effectively setting the starting point for the subsequent exponentialRampToValueAtTime.Acknowledging the Micro-Discontinuity:It is important to reiterate that this sequence may still produce a very slight, often imperceptible, discontinuity. This is due to freqParam.value reflecting the parameter's state at the last render quantum, which is marginally in the past relative to now.12 For most musical portamento applications, this level of imprecision is generally acceptable. The pattern of cancel -> setValueAtTime -> ramp is a common idiom for re-triggering envelopes and ramps.146.2. The cancelAndHoldAtTime() Alternative (If Browser Support Allows)If the target browsers for the application reliably support cancelAndHoldAtTime(), this method offers a theoretically smoother way to interrupt an ongoing automation:JavaScript// let now = audioCtx.currentTime;
freqParam.cancelAndHoldAtTime(now); // Cancels future events AND holds the value precisely at 'now'.
freqParam.exponentialRampToValueAtTime(freq, now + ramp_time); // Starts ramp from this accurately held value.

Benefit: This method is designed to avoid the discontinuity associated with the setValueAtTime(param.value, now) pattern because cancelAndHoldAtTime explicitly calculates and holds the value the parameter would have had precisely at cancelTime. The subsequent ramp then starts directly from this accurately determined value.
Drawback: Its "limited availability" across major browsers makes it a risky choice for web applications requiring broad compatibility.10 It is not currently part of the "Baseline" feature set.
6.3. Best Practices for Re-triggering Ramps and EnvelopesBeyond the specific sequence, consider these general best practices:
Conceptual Atomicity: Treat a sequence like cancelScheduledValues -> setValueAtTime -> ramp as a single, conceptual operation for re-triggering a parameter change.
Consistent now: As shown in the recommended sequence, define now = audioCtx.currentTime once at the beginning of such a sequence and use that now variable consistently for all time parameters within that block of operations. This avoids potential minor timing skew from multiple calls to audioCtx.currentTime, which itself advances.
Managing AudioParam.value Expectations: Understand that reading AudioParam.value provides a snapshot from the immediate past (last render quantum). If extremely precise, sample-accurate ramp interruption is critical and cancelAndHoldAtTime() is not an option, significantly more complex solutions might be necessary. These could involve custom calculations or using an AudioWorklet to manually compute and interpolate values, which is an advanced technique beyond typical AudioParam automation.
Prioritize Scheduling Methods: For changes that involve timing, ramps, or sequences, consistently use the AudioParam scheduling methods (setValueAtTime, linearRampToValueAtTime, etc.) rather than relying solely on setting the .value property directly if complex temporal behavior is desired.15
7. ConclusionThe audioParam.cancelScheduledValues(cancelTime) method is a vital tool in the Web Audio API, serving to remove all scheduled automation events from an AudioParam's timeline that are set to occur at or after the specified cancelTime. This allows for dynamic interruption and redirection of an AudioParam's behavior.For implementing portamento, where an ongoing frequency glide might need to be interrupted to start a new one, the analysis indicates that the following sequence is the most robust and widely compatible:JavaScriptfreqParam.cancelScheduledValues(now);
freqParam.setValueAtTime(freqParam.value, now);
freqParam.exponentialRampToValueAtTime(freq, now + ramp_time);
This sequence (referred to as Sequence 1 in the analysis) is preferred because it logically clears future events, then explicitly attempts to set the starting point of the new ramp using the AudioParam's current (albeit slightly historic) value, and finally schedules the new ramp from this defined point. The alternative sequence, which calls cancelScheduledValues(now) after setValueAtTime(freqParam.value, now), is incorrect because the cancellation negates the setValueAtTime call, leading to an unpredictable start for the new ramp.While browser implementations of AudioParam methods have matured and aligned more closely with W3C specifications (e.g., Firefox's improved handling of the .value setter 13), the subtle timing difference between the value returned by AudioParam.value (from the last render quantum) and AudioContext.currentTime (pointing to the next quantum) is an inherent aspect of the current API design.12 This fundamental timing characteristic, rather than widespread browser-specific bugs in this particular interaction today, is the likely source of any minor discontinuities experienced when using the recommended sequence.Although cancelAndHoldAtTime() offers a theoretically cleaner solution, its limited browser availability restricts its practical use. Therefore, understanding and correctly implementing the cancelScheduledValues -> setValueAtTime -> ramp pattern remains essential. As a general best practice, thorough testing of audio behavior across all target browsers is always recommended for any Web Audio API application.
