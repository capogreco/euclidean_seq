<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Euclidean Tone Generator</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: "Courier New", monospace;
                background: #f0f0f0;
                color: #000;
                padding: 20px;
                overflow-x: auto;
            }

            h1 {
                margin-bottom: 20px;
                font-size: 24px;
            }

            .main-container {
                display: flex;
                gap: 15px;
                min-width: 1200px;
                margin-bottom: 20px;
                align-items: flex-start;
            }

            .tone-column {
                flex: 1;
                background: #fff;
                border: 2px solid #000;
                padding: 15px;
                min-height: 500px;
                display: flex;
                flex-direction: column;
            }

            .column-title {
                font-weight: bold;
                padding: 8px;
                background: #000;
                color: #fff;
                text-align: center;
                margin-bottom: 15px;
            }

            .tones-display {
                flex: 1;
                display: flex;
                flex-direction: column-reverse;
                justify-content: space-between;
                margin-bottom: 15px;
                position: relative;
            }

            .tone-item {
                display: flex;
                align-items: center;
                justify-content: flex-end;
                padding: 2px 0;
                cursor: pointer;
                transition: background 0.2s;
                min-height: 24px;
            }

            .tone-item:hover {
                background: #e0e0e0;
            }

            .tone-item.active {
                font-weight: bold;
            }

            .tone-item.inactive {
                color: #ccc;
            }

            .tone-freq {
                margin-right: 10px;
                font-size: 14px;
                width: 70px;
                text-align: right;
            }

            .tone-dot {
                width: 12px;
                height: 12px;
                border-radius: 50%;
                background: #000;
            }

            .tone-item.inactive .tone-dot {
                background: #ddd;
            }

            .tone-item.playing {
                background: #ffeb3b;
            }

            .euclidean-control {
                background: #f9f9f9;
                border: 1px solid #ccc;
                padding: 8px;
                border-radius: 4px;
                width: 100px;
                flex-shrink: 0;
            }

            .euclidean-control h3 {
                font-size: 12px;
                margin-bottom: 8px;
                text-align: center;
                background: #000;
                color: #fff;
                padding: 4px;
                margin: -8px -8px 8px -8px;
            }

            .control {
                margin: 10px 0;
            }

            .control label {
                font-size: 11px;
                display: block;
                margin-bottom: 4px;
                text-align: center;
            }

            .value-control {
                display: flex;
                align-items: center;
                justify-content: space-between;
                gap: 4px;
            }

            .value-btn {
                width: 20px;
                height: 20px;
                border: 1px solid #000;
                background: #fff;
                cursor: pointer;
                font-size: 12px;
                line-height: 1;
                padding: 0;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .value-btn:hover {
                background: #000;
                color: #fff;
            }

            .value-display {
                flex: 1;
                text-align: center;
                font-size: 14px;
                font-weight: bold;
                padding: 4px;
                background: #f0f0f0;
                border: 1px solid #999;
                cursor: ns-resize;
                user-select: none;
                position: relative;
            }

            .value-display:hover {
                background: #e0e0e0;
            }

            .value-display.dragging {
                background: #d0d0d0;
                border-color: #000;
            }

            .control input[type="number"] {
                width: 100%;
                padding: 2px;
                border: 1px solid #000;
                font-family: inherit;
                font-size: 11px;
            }

            .play-button {
                width: 100%;
                background: #fff;
                border: 2px solid #000;
                padding: 8px;
                cursor: pointer;
                font-family: inherit;
                font-weight: bold;
            }

            .play-button:hover {
                background: #000;
                color: #fff;
            }

            .play-button.playing {
                background: #4caf50;
                color: #fff;
            }

            .global-settings {
                background: #fff;
                border: 2px solid #000;
                padding: 15px;
                width: 150px;
                flex-shrink: 0;
            }

            .global-settings h2 {
                font-size: 14px;
                margin-bottom: 10px;
                background: #000;
                color: #fff;
                padding: 5px;
                text-align: center;
                margin: -15px -15px 10px -15px;
            }

            select {
                padding: 2px;
                border: 1px solid #000;
                font-family: inherit;
                font-size: 12px;
            }

            /* Connection status CSS removed - client-side only */

            .sequence-section {
                background: #fff;
                border: 2px solid #000;
                margin-bottom: 20px;
                padding: 15px;
            }

            .sequence-header {
                background: #000;
                color: #fff;
                margin: -15px -15px 15px -15px;
                padding: 10px;
                text-align: center;
            }

            .sequence-header h2 {
                margin: 0;
                font-size: 18px;
            }

            .sequence-visualization {
                height: 300px;
                background: #f9f9f9;
                border: 1px solid #ccc;
                margin-bottom: 15px;
                position: relative;
                overflow: hidden;
                padding: 0;
                display: flex;
                flex-direction: column;
            }

            .sequence-grid {
                width: 100%;
                height: 100%;
                border-collapse: collapse;
                font-size: 11px;
                table-layout: fixed;
                flex: 1;
            }

            .sequence-grid td {
                border: 1px solid #ddd;
                text-align: center;
                vertical-align: middle;
                position: relative;
                padding: 2px;
                min-height: 24px;
                height: auto;
            }

            .sequence-grid .note-cell {
                border-left: 1px solid #ddd;
                border-right: 1px solid #ddd;
                border-top: 1px solid #ddd;
                border-bottom: 1px solid #ddd;
                background: #fff;
                transition: background-color 0.2s;
            }

            .sequence-grid .freq-label {
                width: 80px;
                min-width: 80px;
                text-align: right;
                padding-right: 6px;
                border-right: 2px solid #ccc;
                border-top: 1px solid #ddd;
                border-bottom: 1px solid #ddd;
                border-left: none;
                font-weight: bold;
                background: #f0f0f0;
                font-size: 10px;
            }

            .sequence-grid .step-header {
                font-weight: bold;
                background: #f0f0f0;
                border-top: none;
                border-bottom: 2px solid #ccc;
                border-left: 1px solid #ddd;
                border-right: 1px solid #ddd;
                font-size: 10px;
                padding: 4px 2px;
            }

            .sequence-grid .porta-label {
                background: #e0e0e0;
                font-style: italic;
            }

            .sequence-grid .active-note {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: #000;
                width: 100%;
                height: 100%;
            }

            .sequence-grid .porta-active {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: #666;
                width: 100%;
                height: 100%;
            }

            .sequence-grid .current-column {
                background: #ffeb3b !important;
            }

            .sequence-grid .current-column.active-note {
                background: #000 !important;
                box-shadow: 0 0 0 3px #ffeb3b;
            }

            .sequence-controls {
                display: flex;
                gap: 20px;
                align-items: flex-start;
                flex-wrap: wrap;
            }

            .sequence-control-group {
                background: #f9f9f9;
                border: 1px solid #ccc;
                padding: 10px;
                border-radius: 4px;
                min-width: 120px;
            }

            .sequence-control-group h3 {
                font-size: 12px;
                margin: -10px -10px 10px -10px;
                padding: 5px;
                background: #000;
                color: #fff;
                text-align: center;
            }
        </style>
    </head>
    <body>
        <!-- Connection status removed - client-side only -->

        <h1>Euclidean Tone Generator</h1>

        <div class="sequence-section">
            <div class="sequence-header">
                <h2>PATTERN & PLAYBACK</h2>
            </div>
            <div class="sequence-visualization">
                <!-- Sequence visualization will go here -->
            </div>
            <div class="sequence-controls">
                <div class="sequence-control-group">
                    <h3>Tempo</h3>
                    <div class="control">
                        <label>CPM</label>
                        <div class="value-control">
                            <button
                                class="value-btn"
                                data-target="cpm"
                                data-delta="-5"
                            >
                                −
                            </button>
                            <div
                                class="value-display"
                                id="cpmValue"
                                data-min="10"
                                data-max="240"
                                data-default="30"
                            >
                                30
                            </div>
                            <button
                                class="value-btn"
                                data-target="cpm"
                                data-delta="5"
                            >
                                +
                            </button>
                        </div>
                    </div>
                </div>

                <div class="sequence-control-group">
                    <h3>Pattern</h3>
                    <div class="control">
                        <label>Mode</label>
                        <select id="synthMode" style="width: 100%">
                            <option value="mono">Mono</option>
                            <option value="poly">Poly</option>
                        </select>
                    </div>
                    <div class="control" id="patternStepsControl">
                        <label>Steps</label>
                        <div class="value-control">
                            <button
                                class="value-btn"
                                data-target="patternSteps"
                                data-delta="-1"
                            >
                                −
                            </button>
                            <div
                                class="value-display"
                                id="patternStepsValue"
                                data-min="4"
                                data-max="32"
                                data-default="16"
                            >
                                16
                            </div>
                            <button
                                class="value-btn"
                                data-target="patternSteps"
                                data-delta="1"
                            >
                                +
                            </button>
                        </div>
                    </div>
                    <div class="control">
                        <label>Order</label>
                        <select id="sequenceOrder" style="width: 100%">
                            <option value="forward">Forward</option>
                            <option value="reverse">Reverse</option>
                            <option value="random">Random</option>
                            <option value="shuffle">Shuffle</option>
                        </select>
                    </div>
                    <div
                        class="control"
                        id="sequenceShuffleControl"
                        style="display: none"
                    >
                        <button
                            class="play-button"
                            id="reshuffleButton"
                            style="background: #fff"
                        >
                            ↻ Reshuffle
                        </button>
                    </div>
                </div>

                <div
                    class="sequence-control-group poly-only"
                    style="display: none"
                >
                    <h3>Rhythm</h3>
                    <div class="control">
                        <label>Pulses</label>
                        <div class="value-control">
                            <button
                                class="value-btn"
                                data-target="rhythmPulses"
                                data-delta="-1"
                            >
                                −
                            </button>
                            <div
                                class="value-display"
                                id="rhythmPulsesValue"
                                data-min="1"
                                data-max="16"
                                data-default="8"
                            >
                                8
                            </div>
                            <button
                                class="value-btn"
                                data-target="rhythmPulses"
                                data-delta="1"
                            >
                                +
                            </button>
                        </div>
                    </div>
                    <div class="control">
                        <label>Rotation</label>
                        <div class="value-control">
                            <button
                                class="value-btn"
                                data-target="rhythmRotation"
                                data-delta="-1"
                            >
                                −
                            </button>
                            <div
                                class="value-display"
                                id="rhythmRotationValue"
                                data-min="0"
                                data-max="15"
                                data-default="0"
                            >
                                0
                            </div>
                            <button
                                class="value-btn"
                                data-target="rhythmRotation"
                                data-delta="1"
                            >
                                +
                            </button>
                        </div>
                    </div>
                </div>

                <div class="sequence-control-group mono-only">
                    <h3>Portamento</h3>
                    <div class="control">
                        <label>Time (ms)</label>
                        <div class="value-control">
                            <button
                                class="value-btn"
                                data-target="portamentoTime"
                                data-delta="-10"
                            >
                                −
                            </button>
                            <div
                                class="value-display"
                                id="portamentoTimeValue"
                                data-min="0"
                                data-max="500"
                                data-default="50"
                            >
                                50
                            </div>
                            <button
                                class="value-btn"
                                data-target="portamentoTime"
                                data-delta="10"
                            >
                                +
                            </button>
                        </div>
                    </div>
                    <div class="control">
                        <label>Steps</label>
                        <div class="value-control">
                            <button
                                class="value-btn"
                                data-target="portamentoSteps"
                                data-delta="-1"
                            >
                                −
                            </button>
                            <div
                                class="value-display"
                                id="portamentoStepsValue"
                                data-min="0"
                                data-max="16"
                                data-default="4"
                            >
                                4
                            </div>
                            <button
                                class="value-btn"
                                data-target="portamentoSteps"
                                data-delta="1"
                            >
                                +
                            </button>
                        </div>
                    </div>
                    <div class="control">
                        <label>Rotation</label>
                        <div class="value-control">
                            <button
                                class="value-btn"
                                data-target="portamentoRotation"
                                data-delta="-1"
                            >
                                −
                            </button>
                            <div
                                class="value-display"
                                id="portamentoRotationValue"
                                data-min="0"
                                data-max="15"
                                data-default="0"
                            >
                                0
                            </div>
                            <button
                                class="value-btn"
                                data-target="portamentoRotation"
                                data-delta="1"
                            >
                                +
                            </button>
                        </div>
                    </div>
                </div>

                <div
                    class="sequence-control-group poly-only"
                    style="display: none"
                >
                    <h3>Envelope</h3>
                    <div class="control">
                        <label>Attack (ms)</label>
                        <div class="value-control">
                            <button
                                class="value-btn"
                                data-target="attackTime"
                                data-delta="-5"
                            >
                                −
                            </button>
                            <div
                                class="value-display"
                                id="attackTimeValue"
                                data-min="0"
                                data-max="100"
                                data-default="5"
                            >
                                5
                            </div>
                            <button
                                class="value-btn"
                                data-target="attackTime"
                                data-delta="5"
                            >
                                +
                            </button>
                        </div>
                    </div>
                    <div class="control">
                        <label>Decay (ms)</label>
                        <div class="value-control">
                            <button
                                class="value-btn"
                                data-target="decayTime"
                                data-delta="-10"
                            >
                                −
                            </button>
                            <div
                                class="value-display"
                                id="decayTimeValue"
                                data-min="50"
                                data-max="500"
                                data-default="200"
                            >
                                200
                            </div>
                            <button
                                class="value-btn"
                                data-target="decayTime"
                                data-delta="10"
                            >
                                +
                            </button>
                        </div>
                    </div>
                </div>

                <button
                    class="play-button"
                    id="playSequence"
                    style="width: 100px; height: 40px; font-size: 16px"
                >
                    ▶ Play
                </button>
            </div>
        </div>

        <div class="main-container">
            <div class="global-settings">
                <h2>SETTINGS</h2>
                <div class="control">
                    <label>EDO (Base Tones)</label>
                    <div class="value-control">
                        <button
                            class="value-btn"
                            data-target="edo"
                            data-delta="-1"
                        >
                            −
                        </button>
                        <div
                            class="value-display"
                            id="edoValue"
                            data-min="5"
                            data-max="24"
                            data-default="12"
                        >
                            12
                        </div>
                        <button
                            class="value-btn"
                            data-target="edo"
                            data-delta="1"
                        >
                            +
                        </button>
                    </div>
                </div>
                <div class="control">
                    <label>Root Note</label>
                    <select
                        id="rootMode"
                        style="width: 100%; margin-bottom: 4px"
                    >
                        <option value="hz">Hz</option>
                        <option value="midi">MIDI</option>
                    </select>
                    <input
                        type="number"
                        id="rootFreq"
                        value="261.63"
                        step="0.01"
                        style="width: 100%"
                    />
                    <select
                        id="rootMidi"
                        style="width: 100%; display: none"
                    ></select>
                </div>
            </div>
            <div class="tone-column">
                <div class="column-title">BASE TONES</div>
                <div class="tones-display" id="baseTones"></div>
                <button class="play-button" id="playBase">▶ Play</button>
            </div>

            <div class="euclidean-control">
                <h3>EUCLIDEAN 1</h3>
                <div class="control">
                    <label>Notes</label>
                    <div class="value-control">
                        <button
                            class="value-btn"
                            data-target="scaleNotes"
                            data-delta="-1"
                        >
                            −
                        </button>
                        <div
                            class="value-display"
                            id="scaleNotesValue"
                            data-min="1"
                            data-max="12"
                            data-default="7"
                        >
                            7
                        </div>
                        <button
                            class="value-btn"
                            data-target="scaleNotes"
                            data-delta="1"
                        >
                            +
                        </button>
                    </div>
                </div>
                <div class="control">
                    <label>Rotation</label>
                    <div class="value-control">
                        <button
                            class="value-btn"
                            data-target="scaleRotation"
                            data-delta="-1"
                        >
                            −
                        </button>
                        <div
                            class="value-display"
                            id="scaleRotationValue"
                            data-min="0"
                            data-max="6"
                            data-default="0"
                        >
                            0
                        </div>
                        <button
                            class="value-btn"
                            data-target="scaleRotation"
                            data-delta="1"
                        >
                            +
                        </button>
                    </div>
                </div>
            </div>

            <div class="tone-column">
                <div class="column-title">SCALE TONES</div>
                <div class="tones-display" id="scaleTones"></div>
                <button class="play-button" id="playScale">▶ Play</button>
            </div>

            <div class="euclidean-control">
                <h3>EUCLIDEAN 2</h3>
                <div class="control">
                    <label>Notes</label>
                    <div class="value-control">
                        <button
                            class="value-btn"
                            data-target="chordNotes"
                            data-delta="-1"
                        >
                            −
                        </button>
                        <div
                            class="value-display"
                            id="chordNotesValue"
                            data-min="1"
                            data-max="7"
                            data-default="3"
                        >
                            3
                        </div>
                        <button
                            class="value-btn"
                            data-target="chordNotes"
                            data-delta="1"
                        >
                            +
                        </button>
                    </div>
                </div>
                <div class="control">
                    <label>Rotation</label>
                    <div class="value-control">
                        <button
                            class="value-btn"
                            data-target="chordRotation"
                            data-delta="-1"
                        >
                            −
                        </button>
                        <div
                            class="value-display"
                            id="chordRotationValue"
                            data-min="0"
                            data-max="2"
                            data-default="0"
                        >
                            0
                        </div>
                        <button
                            class="value-btn"
                            data-target="chordRotation"
                            data-delta="1"
                        >
                            +
                        </button>
                    </div>
                </div>
            </div>

            <div class="tone-column">
                <div class="column-title">CHORD TONES</div>
                <div class="tones-display" id="chordTones"></div>
                <button class="play-button" id="playChord">▶ Play</button>
            </div>

            <div class="euclidean-control">
                <h3>TONE SELECTION</h3>
                <div class="control">
                    <label>Base</label>
                    <div class="value-control">
                        <button
                            class="value-btn"
                            data-target="sequenceBase"
                            data-delta="-1"
                        >
                            −
                        </button>
                        <div
                            class="value-display"
                            id="sequenceBaseValue"
                            data-min="-2"
                            data-max="2"
                            data-default="0"
                        >
                            0
                        </div>
                        <button
                            class="value-btn"
                            data-target="sequenceBase"
                            data-delta="1"
                        >
                            +
                        </button>
                    </div>
                </div>
                <div class="control">
                    <label>Octaves</label>
                    <div class="value-control">
                        <button
                            class="value-btn"
                            data-target="sequenceOctaves"
                            data-delta="-1"
                        >
                            −
                        </button>
                        <div
                            class="value-display"
                            id="sequenceOctavesValue"
                            data-min="1"
                            data-max="4"
                            data-default="2"
                        >
                            2
                        </div>
                        <button
                            class="value-btn"
                            data-target="sequenceOctaves"
                            data-delta="1"
                        >
                            +
                        </button>
                    </div>
                </div>
                <div class="control">
                    <label>Notes</label>
                    <div class="value-control">
                        <button
                            class="value-btn"
                            data-target="sequenceNotes"
                            data-delta="-1"
                        >
                            −
                        </button>
                        <div
                            class="value-display"
                            id="sequenceNotesValue"
                            data-min="1"
                            data-max="6"
                            data-default="6"
                        >
                            6
                        </div>
                        <button
                            class="value-btn"
                            data-target="sequenceNotes"
                            data-delta="1"
                        >
                            +
                        </button>
                    </div>
                </div>
                <div class="control">
                    <label>Method</label>
                    <select id="sequenceMethod" style="width: 100%">
                        <option value="euclidean">Euclidean</option>
                        <option value="random">Random</option>
                    </select>
                </div>
                <div
                    class="control"
                    id="sequenceRotationControl"
                    style="display: block"
                >
                    <label>Rotation</label>
                    <div class="value-control">
                        <button
                            class="value-btn"
                            data-target="sequenceRotation"
                            data-delta="-1"
                        >
                            −
                        </button>
                        <div
                            class="value-display"
                            id="sequenceRotationValue"
                            data-min="0"
                            data-max="7"
                            data-default="0"
                        >
                            0
                        </div>
                        <button
                            class="value-btn"
                            data-target="sequenceRotation"
                            data-delta="1"
                        >
                            +
                        </button>
                    </div>
                </div>
                <div
                    class="control"
                    id="sequenceRandomizeControl"
                    style="display: none"
                >
                    <button
                        id="randomizeSequence"
                        style="
                            width: 100%;
                            padding: 8px;
                            background: #000;
                            color: #fff;
                            border: none;
                            cursor: pointer;
                        "
                    >
                        Randomize
                    </button>
                </div>
            </div>

            <div class="tone-column">
                <div class="column-title">SELECTED TONES</div>
                <div class="tones-display" id="sequenceTones"></div>
                <button class="play-button" id="playSequenceTones">
                    ▶ Play
                </button>
            </div>
        </div>

        <script>
            const audioContext = new (window.AudioContext ||
                window.webkitAudioContext)();
            // Euclidean algorithm implementation
            function euclideanRhythm(pulses, steps) {
                if (pulses > steps) return [];
                if (pulses === 0) return new Array(steps).fill(false);
                if (pulses === steps) return new Array(steps).fill(true);

                const pattern = [];
                for (let i = 0; i < steps; i++) {
                    pattern.push([i < pulses]);
                }

                let level = 0;
                while (pattern.length > 1 && pattern.length - pulses > 0) {
                    const count = Math.min(pulses, pattern.length - pulses);
                    for (let i = 0; i < count; i++) {
                        pattern[i].push(...pattern[pattern.length - 1]);
                        pattern.pop();
                    }
                    level++;
                    pulses = pattern.length - count;
                }

                return pattern.flat();
            }

            // Simplified Pipeline - Pure Functions
            class TonePipeline {
                constructor() {
                    this.params = {
                        edo: 12,
                        rootFreq: 261.63,
                        scaleNotes: 7,
                        scaleRotation: 0,
                        chordNotes: 4,
                        chordRotation: 0,
                        sequenceNotes: 8,
                        sequenceMethod: "euclidean",
                        sequenceBase: 0,
                        sequenceOctaves: 2,
                        sequenceRotation: 0,
                    };

                    // Shuffle cache integrated into pipeline
                    this.shuffleCache = {
                        mono: null,
                        poly: null,
                    };
                }

                // Get current data in the old format for compatibility
                getCurrentData() {
                    const baseTones = this.generateBaseTones(
                        this.params.edo,
                        this.params.rootFreq,
                    );
                    const { scaleTones, scaleIndices } =
                        this.generateScaleTones(
                            baseTones,
                            this.params.scaleNotes,
                            this.params.scaleRotation,
                        );
                    const { chordTones, chordIndices } =
                        this.generateChordTones(
                            scaleTones,
                            scaleIndices,
                            this.params.chordNotes,
                            this.params.chordRotation,
                        );
                    const { sequenceTones, sequenceIndices } =
                        this.generateSequenceTones(
                            chordTones,
                            chordIndices,
                            this.params.sequenceNotes,
                            this.params.sequenceMethod,
                            this.params.sequenceBase,
                            this.params.sequenceOctaves,
                            this.params.sequenceRotation,
                        );

                    return {
                        baseTones,
                        scaleTones,
                        scaleIndices,
                        chordTones,
                        chordIndices,
                        sequenceTones,
                        sequenceIndices,
                    };
                }

                updateParam(paramName, value) {
                    this.params[paramName] = value;

                    // Clear shuffle cache when tones change
                    if (
                        [
                            "edo",
                            "rootFreq",
                            "scaleNotes",
                            "scaleRotation",
                            "chordNotes",
                            "chordRotation",
                            "sequenceNotes",
                            "sequenceMethod",
                            "sequenceBase",
                            "sequenceOctaves",
                            "sequenceRotation",
                        ].includes(paramName)
                    ) {
                        this.clearShuffleCache();
                    }
                }

                // Order tones according to specified method
                orderTones(tones, method) {
                    switch (method) {
                        case "forward":
                            this.shuffleCache.mono = null;
                            this.shuffleCache.poly = null;
                            return [...tones].sort((a, b) => a - b);

                        case "reverse":
                            this.shuffleCache.mono = null;
                            this.shuffleCache.poly = null;
                            return [...tones].sort((a, b) => b - a);

                        case "shuffle":
                            // Use mode-specific cache
                            const cacheKey =
                                appState.get("synthMode") || "mono";
                            if (
                                !this.shuffleCache[cacheKey] ||
                                this.shuffleCache[cacheKey].length !==
                                    tones.length
                            ) {
                                this.shuffleCache[cacheKey] = [...tones];
                                // Fisher-Yates shuffle
                                for (
                                    let i =
                                        this.shuffleCache[cacheKey].length - 1;
                                    i > 0;
                                    i--
                                ) {
                                    const j = Math.floor(
                                        Math.random() * (i + 1),
                                    );
                                    [
                                        this.shuffleCache[cacheKey][i],
                                        this.shuffleCache[cacheKey][j],
                                    ] = [
                                        this.shuffleCache[cacheKey][j],
                                        this.shuffleCache[cacheKey][i],
                                    ];
                                }
                            }
                            return [...this.shuffleCache[cacheKey]];

                        case "random":
                        default:
                            this.shuffleCache.mono = null;
                            this.shuffleCache.poly = null;
                            return [...tones]; // Keep original order for random
                    }
                }

                // Clear shuffle cache
                clearShuffleCache() {
                    this.shuffleCache.mono = null;
                    this.shuffleCache.poly = null;
                }

                // Reshuffle - force new shuffle
                reshuffle() {
                    this.clearShuffleCache();
                }
            }

            // Add tone generation methods to the pipeline
            TonePipeline.prototype.generateBaseTones = function (
                edo,
                rootFreq,
            ) {
                const tones = [];
                for (let i = 0; i <= edo; i++) {
                    tones.push(rootFreq * Math.pow(2, i / edo));
                }
                return tones;
            };

            TonePipeline.prototype.generateScaleTones = function (
                baseTones,
                scaleNotes,
                scaleRotation,
            ) {
                const edo = baseTones.length - 1;
                const pattern = euclideanRhythm(scaleNotes, edo);

                // Get original positions
                const originalPositions = [];
                pattern.forEach((hasNote, index) => {
                    if (hasNote) {
                        originalPositions.push(index);
                    }
                });

                if (originalPositions.length === 0) {
                    return {
                        scaleTones: new Array(edo + 1).fill(0),
                        scaleIndices: [],
                    };
                }

                // Calculate intervals
                const originalIntervals = [];
                for (let i = 0; i < originalPositions.length; i++) {
                    const current = originalPositions[i];
                    const next =
                        originalPositions[(i + 1) % originalPositions.length];
                    const interval =
                        next > current ? next - current : edo - current + next;
                    originalIntervals.push(interval);
                }

                // Apply rotation
                let rotatedIntervals = [...originalIntervals];
                if (scaleRotation > 0 && originalIntervals.length > 0) {
                    const rot = scaleRotation % originalIntervals.length;
                    rotatedIntervals = [
                        ...originalIntervals.slice(rot),
                        ...originalIntervals.slice(0, rot),
                    ];
                }

                // Build scale from intervals
                const steps = [0];
                let currentStep = 0;
                for (let i = 0; i < rotatedIntervals.length - 1; i++) {
                    currentStep += rotatedIntervals[i];
                    steps.push(currentStep);
                }

                // Create scale tones array and indices
                const scaleTones = new Array(edo + 1).fill(0);
                const scaleIndices = [];
                steps.forEach((step) => {
                    if (step <= edo) {
                        scaleTones[step] = baseTones[step];
                        scaleIndices.push(step);
                    }
                });

                // Add octave
                scaleTones[edo] = baseTones[edo];
                if (!scaleIndices.includes(edo)) {
                    scaleIndices.push(edo);
                }

                return { scaleTones, scaleIndices };
            };

            TonePipeline.prototype.generateChordTones = function (
                scaleTones,
                scaleIndices,
                chordNotes,
                chordRotation,
            ) {
                const edo = scaleTones.length - 1;
                const activeScaleTones = scaleIndices.filter((s) => s < edo);

                if (activeScaleTones.length === 0) {
                    return {
                        chordTones: new Array(edo + 1).fill(0),
                        chordIndices: [],
                    };
                }

                const chordPattern = euclideanRhythm(
                    chordNotes,
                    activeScaleTones.length,
                );

                // Get original positions
                const originalPositions = [];
                chordPattern.forEach((hasNote, index) => {
                    if (hasNote) {
                        originalPositions.push(index);
                    }
                });

                if (originalPositions.length === 0) {
                    return {
                        chordTones: new Array(edo + 1).fill(0),
                        chordIndices: [],
                    };
                }

                // Calculate intervals
                const originalIntervals = [];
                for (let i = 0; i < originalPositions.length; i++) {
                    const current = originalPositions[i];
                    const next =
                        originalPositions[(i + 1) % originalPositions.length];
                    const interval =
                        next > current
                            ? next - current
                            : activeScaleTones.length - current + next;
                    originalIntervals.push(interval);
                }

                // Apply rotation
                let rotatedIntervals = [...originalIntervals];
                if (chordRotation > 0 && originalIntervals.length > 0) {
                    const rot = chordRotation % originalIntervals.length;
                    rotatedIntervals = [
                        ...originalIntervals.slice(rot),
                        ...originalIntervals.slice(0, rot),
                    ];
                }

                // Build chord positions
                const chordPositions = [0];
                let currentPosition = 0;
                for (let i = 0; i < rotatedIntervals.length - 1; i++) {
                    currentPosition += rotatedIntervals[i];
                    if (currentPosition < activeScaleTones.length) {
                        chordPositions.push(currentPosition);
                    }
                }

                // Map to actual chord tones
                const chordTones = new Array(edo + 1).fill(0);
                const chordIndices = [];

                chordPositions.forEach((position) => {
                    const step = activeScaleTones[position];
                    chordTones[step] = scaleTones[step];
                    chordIndices.push(step);
                });

                // Add octave if it was in the scale
                if (scaleIndices.includes(edo)) {
                    chordTones[edo] = scaleTones[edo];
                    if (!chordIndices.includes(edo)) {
                        chordIndices.push(edo);
                    }
                }

                return { chordTones, chordIndices };
            };

            TonePipeline.prototype.generateSequenceTones = function (
                chordTones,
                chordIndices,
                sequenceNotes,
                sequenceMethod,
                sequenceBase,
                sequenceOctaves,
                sequenceRotation,
            ) {
                const edo = chordTones.length - 1;

                if (
                    sequenceNotes === undefined ||
                    sequenceBase === undefined ||
                    sequenceOctaves === undefined
                ) {
                    return { sequenceTones: [], sequenceIndices: [] };
                }

                // Expand chord tones across octaves
                const expandedTones = [];

                const minOctave = sequenceBase;
                const maxOctave = sequenceBase + sequenceOctaves - 1;

                for (let octave = minOctave; octave <= maxOctave; octave++) {
                    chordIndices.forEach((index) => {
                        if (index < edo) {
                            const baseTone = chordTones[index];
                            if (baseTone > 0) {
                                const freq = baseTone * Math.pow(2, octave);
                                expandedTones.push(freq);
                            }
                        }
                    });
                }

                if (expandedTones.length === 0) {
                    return { sequenceTones: [], sequenceIndices: [] };
                }

                // Select subset using chosen method
                let selectedIndices = [];

                if (sequenceMethod === "euclidean") {
                    const numToSelect = Math.min(
                        sequenceNotes,
                        expandedTones.length,
                    );
                    const pattern = euclideanRhythm(
                        numToSelect,
                        expandedTones.length,
                    );

                    // Apply rotation
                    let rotatedPattern = [...pattern];
                    if (sequenceRotation && sequenceRotation > 0) {
                        const rot = sequenceRotation % expandedTones.length;
                        rotatedPattern = [
                            ...pattern.slice(rot),
                            ...pattern.slice(0, rot),
                        ];
                    }

                    rotatedPattern.forEach((select, i) => {
                        if (select) {
                            selectedIndices.push(i);
                        }
                    });
                } else if (sequenceMethod === "random") {
                    const numToSelect = Math.min(
                        sequenceNotes,
                        expandedTones.length,
                    );
                    const available = [...Array(expandedTones.length).keys()];
                    for (let i = 0; i < numToSelect; i++) {
                        const randomIndex = Math.floor(
                            Math.random() * available.length,
                        );
                        selectedIndices.push(available[randomIndex]);
                        available.splice(randomIndex, 1);
                    }
                    selectedIndices.sort((a, b) => a - b);
                }

                // Return selected tones
                const sequenceTones = expandedTones.map((freq, i) =>
                    selectedIndices.includes(i) ? freq : 0,
                );

                return { sequenceTones, sequenceIndices: selectedIndices };
            };

            // Centralized Application State
            class AppState {
                constructor() {
                    // UI Parameters - single source of truth
                    this.params = {
                        edo: 12,
                        scaleNotes: 7,
                        scaleRotation: 0,
                        chordNotes: 4,
                        chordRotation: 0,
                        rootFreq: 261.63,
                        sequenceNotes: 8,
                        sequenceMethod: "euclidean",
                        sequenceBase: 0,
                        sequenceOctaves: 2,
                        sequenceRotation: 0,
                        cpm: 30,
                        portamentoSteps: 4,
                        portamentoRotation: 0,
                        portamentoTime: 100,
                        rhythmPulses: 4,
                        rhythmRotation: 0,
                        patternSteps: 8,
                        attackTime: 10,
                        decayTime: 100,
                        synthMode: "mono",
                        sequenceOrder: "forward",
                    };

                    // Playback State
                    this.playback = {
                        sequenceInterval: null,
                        sequencePattern: {
                            steps: [],
                            rhythm: [],
                            portamento: [],
                            currentStep: 0,
                        },
                        playIntervals: {
                            base: null,
                            scale: null,
                            chord: null,
                            sequence: null,
                        },
                        playIndices: {
                            base: 0,
                            scale: 0,
                            chord: 0,
                            sequence: 0,
                        },
                        monoOsc: null,
                        monoGain: null,
                        currentMonoFreq: null,
                        // Master phasor timing system
                        phasor: 0, // 0-1 representing position in sequence
                        startTime: 0, // performance.now() when sequence started
                        lastUpdateTime: 0, // Last time phasor was updated
                        isPlaying: false, // Whether sequence is actively playing
                        animationFrame: null, // requestAnimationFrame ID for smooth updates
                    };

                    // Event listeners for parameter changes
                    this.listeners = new Map();
                }

                // Get parameter value
                get(paramName) {
                    return this.params[paramName];
                }

                // Set parameter value and notify listeners
                set(paramName, value) {
                    if (this.params[paramName] !== value) {
                        const oldValue = this.params[paramName];
                        this.params[paramName] = value;
                        this.notifyChange(paramName, value, oldValue);
                    }
                }

                // Update multiple parameters at once
                update(updates) {
                    const changes = [];
                    for (const [key, value] of Object.entries(updates)) {
                        if (this.params[key] !== value) {
                            changes.push({
                                param: key,
                                value,
                                oldValue: this.params[key],
                            });
                            this.params[key] = value;
                        }
                    }
                    changes.forEach(({ param, value, oldValue }) =>
                        this.notifyChange(param, value, oldValue),
                    );
                }

                // Add change listener
                onChange(paramName, callback) {
                    if (!this.listeners.has(paramName)) {
                        this.listeners.set(paramName, []);
                    }
                    this.listeners.get(paramName).push(callback);
                }

                // Notify parameter change
                notifyChange(paramName, newValue, oldValue) {
                    const callbacks = this.listeners.get(paramName) || [];
                    callbacks.forEach((callback) =>
                        callback(newValue, oldValue, paramName),
                    );
                }

                // Sync with DOM elements (for initialization)
                syncFromDOM() {
                    const elements = [
                        "edo",
                        "scaleNotes",
                        "scaleRotation",
                        "chordNotes",
                        "chordRotation",
                        "sequenceNotes",
                        "sequenceBase",
                        "sequenceOctaves",
                        "sequenceRotation",
                        "cpm",
                        "portamentoSteps",
                        "portamentoRotation",
                        "portamentoTime",
                        "rhythmPulses",
                        "rhythmRotation",
                        "patternSteps",
                        "attackTime",
                        "decayTime",
                    ];

                    elements.forEach((param) => {
                        const element = document.getElementById(
                            param + "Value",
                        );
                        if (element) {
                            this.params[param] =
                                parseInt(element.textContent) ||
                                this.params[param];
                        }
                    });

                    // Special cases
                    const modeElement = document.getElementById("synthMode");
                    if (modeElement) this.params.synthMode = modeElement.value;

                    const orderElement =
                        document.getElementById("sequenceOrder");
                    if (orderElement)
                        this.params.sequenceOrder = orderElement.value;

                    const methodElement =
                        document.getElementById("sequenceMethod");
                    if (methodElement)
                        this.params.sequenceMethod = methodElement.value;
                }

                // Sync to DOM elements
                syncToDOM() {
                    Object.entries(this.params).forEach(([param, value]) => {
                        const element = document.getElementById(
                            param + "Value",
                        );
                        if (element) {
                            element.textContent = value;
                        }
                    });

                    // Special cases
                    document.getElementById("synthMode").value =
                        this.params.synthMode;
                    document.getElementById("sequenceOrder").value =
                        this.params.sequenceOrder;
                    document.getElementById("sequenceMethod").value =
                        this.params.sequenceMethod;
                }

                // Master Phasor Timing System Methods
                getCurrentStep() {
                    const patternLength =
                        this.playback.sequencePattern.steps.length;
                    if (patternLength === 0) return 0;
                    return Math.floor(this.playback.phasor * patternLength);
                }

                updatePhasor() {
                    if (!this.playback.isPlaying) return;

                    const now = performance.now();

                    // Calculate ideal phasor position based on elapsed time from start
                    const cpm = this.params.cpm;
                    const cycleTimeMs = 60000 / cpm; // One complete cycle time
                    const elapsedTime = now - this.playback.startTime;
                    const idealPhasor = (elapsedTime / cycleTimeMs) % 1.0;

                    // Drift correction: blend current phasor with ideal position
                    // This compensates for accumulated timing errors
                    const correctionFactor = 0.1; // How quickly to correct drift (0.1 = 10% per frame)
                    const phasorError = idealPhasor - this.playback.phasor;

                    // Handle wraparound (when ideal phasor crosses 0)
                    let correctedError = phasorError;
                    if (phasorError > 0.5) {
                        correctedError = phasorError - 1.0;
                    } else if (phasorError < -0.5) {
                        correctedError = phasorError + 1.0;
                    }

                    // Apply correction
                    this.playback.phasor += correctedError * correctionFactor;

                    // Ensure phasor stays in 0-1 range
                    if (this.playback.phasor < 0) this.playback.phasor += 1.0;
                    if (this.playback.phasor >= 1.0)
                        this.playback.phasor -= 1.0;

                    this.playback.lastUpdateTime = now;

                    return this.getCurrentStep();
                }

                startPhasorSequence() {
                    const now = performance.now();
                    this.playback.isPlaying = true;
                    this.playback.startTime = now;
                    this.playback.lastUpdateTime = now;
                    this.playback.phasor = 0;

                    // Start animation loop for smooth updates
                    const animate = () => {
                        if (!this.playback.isPlaying) return;

                        const currentStep = this.updatePhasor();

                        // Check for step changes
                        if (
                            currentStep !==
                            this.playback.sequencePattern.currentStep
                        ) {
                            this.playback.sequencePattern.currentStep =
                                currentStep;
                            this.triggerSequenceStep(currentStep);
                        }

                        // Update visualization continuously for smooth progress
                        this.updateSequenceVisualization();

                        this.playback.animationFrame =
                            requestAnimationFrame(animate);
                    };

                    this.playback.animationFrame =
                        requestAnimationFrame(animate);
                }

                stopPhasorSequence() {
                    this.playback.isPlaying = false;
                    this.playback.phasor = 0;
                    this.playback.sequencePattern.currentStep = 0;

                    if (this.playback.animationFrame) {
                        cancelAnimationFrame(this.playback.animationFrame);
                        this.playback.animationFrame = null;
                    }
                }

                triggerSequenceStep(step) {
                    const freq = this.playback.sequencePattern.steps[step];
                    const mode = this.params.synthMode;

                    if (!freq) return; // No frequency for this step

                    if (mode === "mono") {
                        this.triggerMonoStep(step, freq);
                    } else {
                        this.triggerPolyStep(step, freq);
                    }
                }

                triggerMonoStep(step, freq) {
                    if (!this.playback.monoOsc) return;

                    const hasPortamento =
                        this.playback.sequencePattern.portamento[step];
                    const now = audioContext.currentTime;

                    if (
                        hasPortamento &&
                        this.playback.currentMonoFreq &&
                        this.playback.currentMonoFreq !== freq
                    ) {
                        this.playback.monoOsc.frequency.cancelScheduledValues(
                            now,
                        );
                        const currentFreq =
                            this.playback.monoOsc.frequency.value;
                        this.playback.monoOsc.frequency.setValueAtTime(
                            currentFreq,
                            now,
                        );
                        const portamentoTime =
                            this.params.portamentoTime / 1000; // Convert to seconds

                        // Use exponential ramp for musical intervals, linear ramp as fallback
                        try {
                            if (currentFreq > 0 && freq > 0) {
                                this.playback.monoOsc.frequency.exponentialRampToValueAtTime(
                                    freq,
                                    now + portamentoTime,
                                );
                            } else {
                                this.playback.monoOsc.frequency.linearRampToValueAtTime(
                                    freq,
                                    now + portamentoTime,
                                );
                            }
                        } catch (e) {
                            // Fallback to linear ramp if exponential fails
                            this.playback.monoOsc.frequency.linearRampToValueAtTime(
                                freq,
                                now + portamentoTime,
                            );
                        }
                    } else {
                        // Non-portamento step: cancel any ongoing portamento and jump immediately
                        this.playback.monoOsc.frequency.cancelScheduledValues(
                            now,
                        );
                        this.playback.monoOsc.frequency.setValueAtTime(
                            this.playback.monoOsc.frequency.value,
                            now,
                        );
                        this.playback.monoOsc.frequency.setValueAtTime(
                            freq,
                            now,
                        );
                    }
                    this.playback.currentMonoFreq = freq;
                }

                triggerPolyStep(step, freq) {
                    const attackTime = this.params.attackTime;
                    const decayTime = this.params.decayTime;

                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();

                    osc.connect(gain);
                    gain.connect(audioContext.destination);

                    osc.frequency.value = freq;
                    osc.type = "sine";

                    gain.gain.setValueAtTime(0, audioContext.currentTime);
                    gain.gain.linearRampToValueAtTime(
                        0.3,
                        audioContext.currentTime + attackTime / 1000,
                    );
                    gain.gain.exponentialRampToValueAtTime(
                        0.01,
                        audioContext.currentTime +
                            (attackTime + decayTime) / 1000,
                    );

                    osc.start(audioContext.currentTime);
                    osc.stop(
                        audioContext.currentTime +
                            (attackTime + decayTime) / 1000,
                    );
                }

                updateSequenceVisualization() {
                    // Update the sequence visualization with current phasor position
                    // This will provide smooth visual feedback
                    if (typeof updateSequenceVisualization === "function") {
                        updateSequenceVisualization();
                    }
                }
            }

            // Global instances
            const appState = new AppState();
            const pipeline = new TonePipeline();

            // Compatibility layer - acts like the old currentData
            let currentData = new Proxy(
                {},
                {
                    get(target, prop) {
                        if (prop === "sequenceIndices") {
                            return pipeline.getCurrentData().sequenceIndices;
                        }
                        return pipeline.getCurrentData()[prop];
                    },
                },
            );
            // Global variables replaced by appState.playback
            // Compatibility getters for existing code
            let playIntervals = {
                get base() {
                    return appState.playback.playIntervals.base;
                },
                set base(val) {
                    appState.playback.playIntervals.base = val;
                },
                get scale() {
                    return appState.playback.playIntervals.scale;
                },
                set scale(val) {
                    appState.playback.playIntervals.scale = val;
                },
                get chord() {
                    return appState.playback.playIntervals.chord;
                },
                set chord(val) {
                    appState.playback.playIntervals.chord = val;
                },
                get sequence() {
                    return appState.playback.playIntervals.sequence;
                },
                set sequence(val) {
                    appState.playback.playIntervals.sequence = val;
                },
            };

            let playIndices = {
                get base() {
                    return appState.playback.playIndices.base;
                },
                set base(val) {
                    appState.playback.playIndices.base = val;
                },
                get scale() {
                    return appState.playback.playIndices.scale;
                },
                set scale(val) {
                    appState.playback.playIndices.scale = val;
                },
                get chord() {
                    return appState.playback.playIndices.chord;
                },
                set chord(val) {
                    appState.playback.playIndices.chord = val;
                },
                get sequence() {
                    return appState.playback.playIndices.sequence;
                },
                set sequence(val) {
                    appState.playback.playIndices.sequence = val;
                },
            };

            // Direct references to appState - using property descriptors
            Object.defineProperty(window, "sequencePattern", {
                get: () => appState.playback.sequencePattern,
                set: (val) => (appState.playback.sequencePattern = val),
            });
            Object.defineProperty(window, "sequenceInterval", {
                get: () => (appState.playback.isPlaying ? "playing" : null),
                set: (val) => {
                    // Legacy compatibility - setting sequenceInterval doesn't make sense with phasor system
                    // This property now reflects the playing state
                },
            });
            Object.defineProperty(window, "monoOsc", {
                get: () => appState.playback.monoOsc,
                set: (val) => (appState.playback.monoOsc = val),
            });
            Object.defineProperty(window, "monoGain", {
                get: () => appState.playback.monoGain,
                set: (val) => (appState.playback.monoGain = val),
            });
            Object.defineProperty(window, "currentMonoFreq", {
                get: () => appState.playback.currentMonoFreq,
                set: (val) => (appState.playback.currentMonoFreq = val),
            });

            // Shuffle cache moved to pipeline

            function generateSequencePattern() {
                const mode = document.getElementById("synthMode").value;
                const order = document.getElementById("sequenceOrder").value;

                let patternSteps,
                    rhythmPulses,
                    rhythmRotation,
                    portamentoSteps,
                    portamentoRotation;

                if (mode === "mono") {
                    // Mono mode: steps = number of sequence tones, no rhythm pattern
                    const activeToneCount = currentData.sequenceIndices
                        ? currentData.sequenceIndices.length
                        : 0;
                    patternSteps = activeToneCount;
                    rhythmPulses = patternSteps; // All steps active in mono
                    rhythmRotation = 0;
                    portamentoSteps = parseInt(
                        document.getElementById("portamentoStepsValue")
                            .textContent,
                    );
                    portamentoRotation = parseInt(
                        document.getElementById("portamentoRotationValue")
                            .textContent,
                    );
                } else {
                    // Poly mode: use UI values
                    patternSteps = parseInt(
                        document.getElementById("patternStepsValue")
                            .textContent,
                    );
                    rhythmPulses = parseInt(
                        document.getElementById("rhythmPulsesValue")
                            .textContent,
                    );
                    rhythmRotation = parseInt(
                        document.getElementById("rhythmRotationValue")
                            .textContent,
                    );
                    portamentoSteps = 0; // No portamento in poly mode
                    portamentoRotation = 0;
                }

                // Get active sequence tones (the selected subset from the expanded pool)
                const activeTones = [];
                if (currentData.sequenceTones && currentData.sequenceIndices) {
                    // Collect all non-zero tones in order
                    for (let i = 0; i < currentData.sequenceTones.length; i++) {
                        if (
                            currentData.sequenceTones[i] > 0 &&
                            currentData.sequenceIndices.includes(i)
                        ) {
                            activeTones.push(currentData.sequenceTones[i]);
                        }
                    }
                }

                if (activeTones.length === 0) {
                    console.log(
                        "No active tones found. Make sure to generate tones first.",
                    );
                    return;
                }

                console.log(
                    `Generating pattern with ${activeTones.length} tones, mode: ${mode}`,
                );

                // Generate rhythm pattern
                let rhythm = euclideanRhythm(rhythmPulses, patternSteps);
                if (rhythmRotation > 0) {
                    const rot = rhythmRotation % patternSteps;
                    rhythm = [...rhythm.slice(rot), ...rhythm.slice(0, rot)];
                }

                // Generate portamento pattern
                let portamento = new Array(patternSteps).fill(false);
                if (portamentoSteps > 0 && patternSteps > 0) {
                    // Ensure portamento steps don't exceed pattern steps
                    const actualPortamentoSteps = Math.min(
                        portamentoSteps,
                        patternSteps,
                    );
                    const portaPattern = euclideanRhythm(
                        actualPortamentoSteps,
                        patternSteps,
                    );
                    if (portamentoRotation > 0) {
                        const rot = portamentoRotation % patternSteps;
                        portamento = [
                            ...portaPattern.slice(rot),
                            ...portaPattern.slice(0, rot),
                        ];
                    } else {
                        portamento = portaPattern;
                    }
                }

                // Generate note order
                const steps = [];
                let noteCounter = 0;

                // Handle ordering differently for mono vs poly
                // mode is already declared at the top of the function

                if (mode === "mono") {
                    // Mono: simple ordering of tones
                    let orderedTones = [...activeTones];

                    // Use pipeline ordering method
                    orderedTones = pipeline.orderTones(activeTones, order);

                    // In mono, all steps have notes (no rests)
                    for (let i = 0; i < patternSteps; i++) {
                        steps.push(orderedTones[i % orderedTones.length]);
                    }

                    // Update portamento steps max based on actual pattern steps
                    document.getElementById(
                        "portamentoStepsValue",
                    ).dataset.max = patternSteps;
                    const currentPortamentoSteps = parseInt(
                        document.getElementById("portamentoStepsValue")
                            .textContent,
                    );
                    if (currentPortamentoSteps > patternSteps) {
                        document.getElementById(
                            "portamentoStepsValue",
                        ).textContent = patternSteps;
                    }
                } else {
                    // Poly mode: use pipeline ordering
                    const orderedTones = pipeline.orderTones(
                        activeTones,
                        order,
                    );

                    for (let i = 0; i < patternSteps; i++) {
                        if (rhythm[i]) {
                            // Use ordered tones for all modes (except random which needs special handling)
                            let noteIndex;
                            if (order === "random") {
                                noteIndex = Math.floor(
                                    Math.random() * orderedTones.length,
                                );
                                steps.push(orderedTones[noteIndex]);
                            } else {
                                noteIndex = noteCounter % orderedTones.length;
                                steps.push(orderedTones[noteIndex]);
                                noteCounter++;
                            }
                        } else {
                            steps.push(null); // Rest
                        }
                    }
                }

                // Write directly to single source of truth
                appState.playback.sequencePattern = {
                    steps,
                    rhythm,
                    portamento,
                    currentStep: appState.playback.sequencePattern
                        ? appState.playback.sequencePattern.currentStep
                        : 0,
                };
            }

            // Update only the portamento pattern without changing the note order
            function updatePortamentoPattern() {
                if (
                    !appState.playback.sequencePattern.steps ||
                    appState.playback.sequencePattern.steps.length === 0
                ) {
                    // If no sequence pattern exists yet, generate it first
                    generateSequencePattern();
                    if (
                        !appState.playback.sequencePattern.steps ||
                        appState.playback.sequencePattern.steps.length === 0
                    ) {
                        return;
                    }
                }

                const patternSteps =
                    appState.playback.sequencePattern.steps.length;
                const portamentoSteps = parseInt(
                    document.getElementById("portamentoStepsValue").textContent,
                );
                const portamentoRotation = parseInt(
                    document.getElementById("portamentoRotationValue")
                        .textContent,
                );

                // Generate new portamento pattern
                let portamento = new Array(patternSteps).fill(false);
                if (portamentoSteps > 0 && patternSteps > 0) {
                    // Ensure portamento steps don't exceed pattern steps
                    const actualPortamentoSteps = Math.min(
                        portamentoSteps,
                        patternSteps,
                    );
                    const portaPattern = euclideanRhythm(
                        actualPortamentoSteps,
                        patternSteps,
                    );
                    if (portamentoRotation > 0) {
                        const rot = portamentoRotation % patternSteps;
                        portamento = [
                            ...portaPattern.slice(rot),
                            ...portaPattern.slice(0, rot),
                        ];
                    } else {
                        portamento = portaPattern;
                    }
                }

                // Update only the portamento pattern, keep existing steps and rhythm
                appState.playback.sequencePattern.portamento = portamento;
            }

            // Duplicate euclideanRhythm function removed - using the one at line 639

            function updateSequenceVisualization() {
                const container = document.querySelector(
                    ".sequence-visualization",
                );
                if (!container) {
                    return;
                }
                if (
                    !appState.playback.sequencePattern.steps ||
                    appState.playback.sequencePattern.steps.length === 0
                ) {
                    console.log("No sequence pattern to visualize");
                    return;
                }

                // Get unique frequencies from sequence pattern
                const uniqueFreqs = [
                    ...new Set(
                        appState.playback.sequencePattern.steps.filter(
                            (f) => f !== null,
                        ),
                    ),
                ].sort((a, b) => b - a);

                // Create grid table
                let html = '<table class="sequence-grid">';

                // Step headers row
                html += '<tr><td class="freq-label"></td>';
                for (
                    let i = 0;
                    i < appState.playback.sequencePattern.steps.length;
                    i++
                ) {
                    html += `<td class="step-header">${i + 1}</td>`;
                }
                html += "</tr>";

                // Portamento row
                html += '<tr><td class="freq-label porta-label">Porta</td>';
                for (
                    let i = 0;
                    i < appState.playback.sequencePattern.portamento.length;
                    i++
                ) {
                    const isActive =
                        appState.playback.sequencePattern.portamento[i];
                    const isCurrent =
                        i === appState.playback.sequencePattern.currentStep;
                    html += `<td class="porta-cell ${isCurrent ? "current-column" : ""}">`;
                    if (isActive) {
                        html += '<div class="porta-active"></div>';
                    }
                    html += "</td>";
                }
                html += "</tr>";

                // Frequency rows
                uniqueFreqs.forEach((freq) => {
                    html += `<tr><td class="freq-label">${freq.toFixed(2)}</td>`;
                    for (
                        let i = 0;
                        i < appState.playback.sequencePattern.steps.length;
                        i++
                    ) {
                        const isActive =
                            appState.playback.sequencePattern.steps[i] === freq;
                        // Only highlight current step if playing
                        const isCurrent =
                            appState.playback.isPlaying &&
                            i === appState.playback.sequencePattern.currentStep;
                        html += `<td class="note-cell ${isCurrent ? "current-column" : ""}">`;
                        if (isActive) {
                            html += `<div class="active-note ${isCurrent ? "current-note" : ""}"></div>`;
                        }
                        html += "</td>";
                    }
                    html += "</tr>";
                });

                html += "</table>";
                container.innerHTML = html;
            }

            function updateSequenceNotesMax() {
                // Calculate max based on chord tones × octaves
                const chordCount = currentData.chordIndices
                    ? currentData.chordIndices.filter(
                          (idx) =>
                              idx <
                              (currentData.baseTones
                                  ? currentData.baseTones.length - 1
                                  : 12),
                      ).length
                    : 3;
                const octaves = parseInt(
                    document.getElementById("sequenceOctavesValue").textContent,
                );
                const maxNotes = chordCount * octaves;

                const sequenceNotesDisplay =
                    document.getElementById("sequenceNotesValue");
                sequenceNotesDisplay.dataset.max = maxNotes;

                // Adjust current value if it exceeds new max
                const currentNotes = parseInt(sequenceNotesDisplay.textContent);
                if (currentNotes > maxNotes) {
                    sequenceNotesDisplay.textContent = maxNotes;
                }

                // Also update rotation max
                const newNotesValue = parseInt(
                    sequenceNotesDisplay.textContent,
                );
                document.getElementById("sequenceRotationValue").dataset.max =
                    Math.max(0, newNotesValue - 1);
            }

            // Function to update sequence playback when parameters change
            function updateSequencePlayback() {
                // With phasor system, timing changes are handled automatically
                // The phasor calculation uses the current CPM value from appState
                // No need to restart intervals - timing updates smoothly in real-time
                if (appState.playback.isPlaying) {
                    console.log("Sequence playback updated for new timing");
                }
            }

            function playSequence() {
                const button = document.getElementById("playSequence");
                const mode = document.getElementById("synthMode").value;

                // Check if we're currently playing (using new phasor system)
                if (appState.playback.isPlaying) {
                    // Stop the phasor sequence
                    appState.stopPhasorSequence();

                    // Clean up UI
                    button.textContent = "▶ Play";
                    button.classList.remove("playing");
                    updateSequenceVisualization();

                    // Stop mono oscillator if running
                    if (mode === "mono" && appState.playback.monoOsc) {
                        appState.playback.monoOsc.stop();
                        appState.playback.monoOsc = null;
                        appState.playback.monoGain = null;
                        appState.playback.currentMonoFreq = null;
                    }
                    return;
                }

                generateSequencePattern();

                if (
                    !appState.playback.sequencePattern.steps ||
                    appState.playback.sequencePattern.steps.length === 0
                ) {
                    console.log("No sequence pattern generated");
                    return;
                }

                button.textContent = "■ Stop";
                button.classList.add("playing");

                if (mode === "mono") {
                    // Create persistent oscillator for mono mode
                    const monoOsc = audioContext.createOscillator();
                    const monoGain = audioContext.createGain();

                    monoOsc.connect(monoGain);
                    monoGain.connect(audioContext.destination);

                    monoOsc.type = "sine";
                    monoGain.gain.value = 0.3;

                    // Start with first frequency
                    const firstFreq =
                        appState.playback.sequencePattern.steps[0];
                    if (firstFreq) {
                        monoOsc.frequency.value = firstFreq;
                        appState.playback.currentMonoFreq = firstFreq;
                    }

                    monoOsc.start();

                    // Store in AppState
                    appState.playback.monoOsc = monoOsc;
                    appState.playback.monoGain = monoGain;
                }

                // Start the phasor-based sequence
                appState.startPhasorSequence();
            }

            // WebSocket function removed - fully client-side now

            function updateParams(params) {
                if (params.edo !== undefined) {
                    document.getElementById("edoValue").textContent =
                        params.edo;
                }
                if (params.rootFreq !== undefined) {
                    document.getElementById("rootFreq").value = params.rootFreq;
                }
            }

            function midiToFreq(midiNote) {
                return 440 * Math.pow(2, (midiNote - 69) / 12);
            }

            function freqToMidi(freq) {
                return Math.round(69 + 12 * Math.log2(freq / 440));
            }

            function getRootFrequency() {
                const mode = document.getElementById("rootMode").value;
                if (mode === "hz") {
                    return parseFloat(
                        document.getElementById("rootFreq").value,
                    );
                } else {
                    const midiNote = parseInt(
                        document.getElementById("rootMidi").value,
                    );
                    return midiToFreq(midiNote);
                }
            }

            function populateMidiDropdown() {
                const noteNames = [
                    "C",
                    "C#",
                    "D",
                    "D#",
                    "E",
                    "F",
                    "F#",
                    "G",
                    "G#",
                    "A",
                    "A#",
                    "B",
                ];
                const select = document.getElementById("rootMidi");
                select.innerHTML = "";

                for (let midi = 24; midi <= 96; midi++) {
                    const octave = Math.floor(midi / 12) - 1;
                    const noteIndex = midi % 12;
                    const option = document.createElement("option");
                    option.value = midi;
                    option.textContent = `${noteNames[noteIndex]}${octave}`;
                    select.appendChild(option);
                }

                select.value = "60";
            }

            // Unified parameter update system
            function updateParameter(paramName, value) {
                // Update AppState
                appState.set(paramName, value);

                // Update pipeline for tone-affecting parameters
                const toneParams = [
                    "edo",
                    "scaleNotes",
                    "scaleRotation",
                    "chordNotes",
                    "chordRotation",
                    "rootFreq",
                    "sequenceNotes",
                    "sequenceMethod",
                    "sequenceBase",
                    "sequenceOctaves",
                    "sequenceRotation",
                ];
                if (toneParams.includes(paramName)) {
                    pipeline.updateParam(paramName, value);
                    updateTonesDisplay();
                }

                // Handle parameter updates that affect patterns/visualization
                if (
                    [
                        "cpm",
                        "rhythmPulses",
                        "rhythmRotation",
                        "patternSteps",
                        "portamentoSteps",
                        "portamentoRotation",
                        "sequenceOrder",
                    ].includes(paramName)
                ) {
                    handleParameterUpdate(paramName);
                }
            }

            // Handle parameter updates that affect patterns/visualization (works when playing OR not playing)
            function handleParameterUpdate(paramName) {
                // Tempo changes - handled automatically by phasor system
                if (paramName === "cpm") {
                    // Phasor system automatically uses updated CPM from appState
                    console.log(
                        "CPM updated - phasor system will adjust timing automatically",
                    );
                }
                // Pattern structure changes
                else if (
                    appState.get("synthMode") === "poly" &&
                    ["rhythmPulses", "rhythmRotation", "patternSteps"].includes(
                        paramName,
                    )
                ) {
                    generateSequencePattern();
                    updateSequenceVisualization();
                }
                // Portamento changes - just update pattern without reshuffling
                else if (
                    appState.get("synthMode") === "mono" &&
                    ["portamentoSteps", "portamentoRotation"].includes(
                        paramName,
                    )
                ) {
                    updatePortamentoPattern();
                    updateSequenceVisualization();
                }
                // Sequence order changes (shuffle/reshuffle)
                else if (paramName === "sequenceOrder") {
                    generateSequencePattern();
                    updateSequenceVisualization();
                }
            }

            // Legacy function for compatibility
            function generateTones() {
                // Sync all parameters from DOM to state and pipeline
                appState.syncFromDOM();

                // Update pipeline with current state
                pipeline.updateParam("edo", appState.get("edo"));
                pipeline.updateParam("scaleNotes", appState.get("scaleNotes"));
                pipeline.updateParam(
                    "scaleRotation",
                    appState.get("scaleRotation"),
                );
                pipeline.updateParam("chordNotes", appState.get("chordNotes"));
                pipeline.updateParam(
                    "chordRotation",
                    appState.get("chordRotation"),
                );
                pipeline.updateParam("rootFreq", getRootFrequency());
                pipeline.updateParam(
                    "sequenceNotes",
                    appState.get("sequenceNotes"),
                );
                pipeline.updateParam(
                    "sequenceMethod",
                    appState.get("sequenceMethod"),
                );
                pipeline.updateParam(
                    "sequenceBase",
                    appState.get("sequenceBase"),
                );
                pipeline.updateParam(
                    "sequenceOctaves",
                    appState.get("sequenceOctaves"),
                );
                pipeline.updateParam(
                    "sequenceRotation",
                    appState.get("sequenceRotation"),
                );

                updateTonesDisplay();

                // Always generate and visualize the sequence pattern
                const currentStep = appState.playback.sequencePattern
                    ? appState.playback.sequencePattern.currentStep
                    : 0;
                generateSequencePattern();
                updateSequenceVisualization();
            }

            function updateTonesDisplay() {
                const data = pipeline.getCurrentData();

                // Reset play indices if the number of tones changed
                if (
                    data.scaleIndices &&
                    playIndices.scale >= data.scaleIndices.length
                ) {
                    playIndices.scale = 0;
                }
                if (
                    data.chordIndices &&
                    playIndices.chord >= data.chordIndices.length
                ) {
                    playIndices.chord = 0;
                }

                displayColumn("baseTones", data.baseTones, true);
                displayColumn("scaleTones", data.scaleTones, data.scaleIndices);
                displayColumn("chordTones", data.chordTones, data.chordIndices);
                displayColumn(
                    "sequenceTones",
                    data.sequenceTones,
                    data.sequenceIndices,
                );

                // Update sequence notes max when chord tones change
                updateSequenceNotesMax();
            }

            // Redundant displayTones function removed - use updateTonesDisplay directly

            function displayColumn(columnId, frequencies, activeIndices) {
                const container = document.getElementById(columnId);
                container.innerHTML = "";

                if (!frequencies || frequencies.length === 0) return;

                // If activeIndices is true, all are active
                // If it's an array, only those indices are active
                const isActive = (index) => {
                    if (activeIndices === true) return true;
                    if (Array.isArray(activeIndices))
                        return activeIndices.includes(index);
                    return false;
                };

                frequencies.forEach((freq, index) => {
                    const item = document.createElement("div");
                    item.className = "tone-item";
                    if (isActive(index)) {
                        item.classList.add("active");
                    } else {
                        item.classList.add("inactive");
                    }

                    const freqSpan = document.createElement("span");
                    freqSpan.className = "tone-freq";
                    freqSpan.textContent = freq > 0 ? freq.toFixed(2) : "";

                    const dot = document.createElement("div");
                    dot.className = "tone-dot";

                    item.appendChild(freqSpan);
                    item.appendChild(dot);

                    if (freq > 0) {
                        item.onclick = () => playNote(freq);
                    }

                    container.appendChild(item);
                });
            }

            function playNote(
                frequency,
                duration = 200,
                portamentoTime = 0,
                previousFreq = null,
            ) {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.connect(gain);
                gain.connect(audioContext.destination);

                if (portamentoTime > 0 && previousFreq) {
                    osc.frequency.setValueAtTime(
                        previousFreq,
                        audioContext.currentTime,
                    );
                    osc.frequency.exponentialRampToValueAtTime(
                        frequency,
                        audioContext.currentTime + portamentoTime / 1000,
                    );
                } else {
                    osc.frequency.value = frequency;
                }
                osc.type = "sine";

                gain.gain.setValueAtTime(0.3, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(
                    0.01,
                    audioContext.currentTime + duration / 1000,
                );

                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + duration / 1000);
            }

            function togglePlay(type) {
                const button = document.getElementById(
                    `play${type.charAt(0).toUpperCase() + type.slice(1)}`,
                );

                if (playIntervals[type]) {
                    clearInterval(playIntervals[type]);
                    playIntervals[type] = null;
                    playIndices[type] = 0;
                    button.textContent = "▶ Play";
                    button.classList.remove("playing");
                    document
                        .querySelectorAll(`#${type}Tones .tone-item`)
                        .forEach((item) => {
                            item.classList.remove("playing");
                        });
                } else {
                    const tones = currentData[`${type}Tones`];
                    const indices =
                        type === "base"
                            ? tones.map((_, i) => i)
                            : type === "scale"
                              ? currentData.scaleIndices
                              : type === "chord"
                                ? currentData.chordIndices
                                : currentData.sequenceIndices;

                    if (!tones || !indices || indices.length === 0) return;

                    button.textContent = "■ Stop";
                    button.classList.add("playing");

                    const playNext = () => {
                        // Get fresh data each time
                        const currentTones = currentData[`${type}Tones`];
                        const currentIndices =
                            type === "base"
                                ? currentTones.map((_, i) => i)
                                : type === "scale"
                                  ? currentData.scaleIndices
                                  : type === "chord"
                                    ? currentData.chordIndices
                                    : currentData.sequenceIndices;

                        if (!currentIndices || currentIndices.length === 0) {
                            clearInterval(playIntervals[type]);
                            playIntervals[type] = null;
                            button.textContent = "▶ Play";
                            button.classList.remove("playing");
                            return;
                        }

                        // Ensure index is within bounds
                        if (playIndices[type] >= currentIndices.length) {
                            playIndices[type] = 0;
                        }

                        const items = document.querySelectorAll(
                            `#${type}Tones .tone-item`,
                        );
                        items.forEach((item) =>
                            item.classList.remove("playing"),
                        );

                        const currentIndex = currentIndices[playIndices[type]];
                        if (items[currentIndex]) {
                            items[currentIndex].classList.add("playing");
                        }

                        const freq = currentTones[currentIndex];
                        if (freq > 0) {
                            playNote(freq, 180);
                        }

                        playIndices[type] =
                            (playIndices[type] + 1) % currentIndices.length;
                    };

                    playNext();
                    playIntervals[type] = setInterval(playNext, 200);
                }
            }

            // Event listeners - removed old slider references since we now use value controls

            document.getElementById("rootMode").onchange = (e) => {
                const mode = e.target.value;
                if (mode === "hz") {
                    document.getElementById("rootFreq").style.display =
                        "inline";
                    document.getElementById("rootMidi").style.display = "none";
                    const midiNote = parseInt(
                        document.getElementById("rootMidi").value,
                    );
                    document.getElementById("rootFreq").value =
                        midiToFreq(midiNote).toFixed(2);
                } else {
                    document.getElementById("rootFreq").style.display = "none";
                    document.getElementById("rootMidi").style.display =
                        "inline";
                    const freq = parseFloat(
                        document.getElementById("rootFreq").value,
                    );
                    const midiNote = freqToMidi(freq);
                    document.getElementById("rootMidi").value = midiNote;
                }
                generateTones();
            };

            document.getElementById("rootFreq").oninput = (e) => {
                generateTones();
            };

            document.getElementById("rootMidi").onchange = (e) => {
                generateTones();
            };

            document.getElementById("sequenceMethod").onchange = (e) => {
                const method = e.target.value;
                const rotationControl = document.getElementById(
                    "sequenceRotationControl",
                );
                const randomizeControl = document.getElementById(
                    "sequenceRandomizeControl",
                );

                if (method === "euclidean") {
                    rotationControl.style.display = "block";
                    randomizeControl.style.display = "none";
                } else if (method === "random") {
                    rotationControl.style.display = "none";
                    randomizeControl.style.display = "block";
                }
                generateTones();
            };

            // Update sequence pattern when order changes
            document.getElementById("sequenceOrder").onchange = (e) => {
                const order = e.target.value;
                // Show/hide reshuffle button
                const reshuffleControl = document.getElementById(
                    "sequenceShuffleControl",
                );
                if (order === "shuffle") {
                    reshuffleControl.style.display = "block";
                } else {
                    reshuffleControl.style.display = "none";
                }

                if (appState.playback.isPlaying) {
                    generateSequencePattern();
                    updateSequenceVisualization();
                }
            };

            document.getElementById("synthMode").onchange = (e) => {
                const mode = e.target.value;

                // Show/hide appropriate controls
                document.querySelectorAll(".mono-only").forEach((el) => {
                    el.style.display = mode === "mono" ? "block" : "none";
                });
                document.querySelectorAll(".poly-only").forEach((el) => {
                    el.style.display = mode === "poly" ? "block" : "none";
                });

                // Hide pattern steps for mono (automatic)
                document.getElementById("patternStepsControl").style.display =
                    mode === "mono" ? "none" : "block";

                // Stop any playing sequence
                if (appState.playback.isPlaying) {
                    document.getElementById("playSequence").click();
                }
            };

            document.getElementById("playBase").onclick = () =>
                togglePlay("base");
            document.getElementById("playScale").onclick = () =>
                togglePlay("scale");
            document.getElementById("playChord").onclick = () =>
                togglePlay("chord");
            document.getElementById("playSequenceTones").onclick = () =>
                togglePlay("sequence");
            document.getElementById("playSequence").onclick = playSequence;

            // Reshuffle button
            document.getElementById("reshuffleButton").onclick = () => {
                // Force a new shuffle using pipeline method
                pipeline.reshuffle();

                // Always regenerate pattern and visualization
                generateSequencePattern();
                updateSequenceVisualization();
            };

            // Randomize button for random sequence method
            document.getElementById("randomizeSequence").onclick = () => {
                // Force regeneration of random sequence tones by clearing any cached selections
                pipeline.clearShuffleCache();

                // Regenerate the sequence tones - this will automatically update pattern and visualization
                generateTones();
            };

            // Value control system with drag support
            function setupValueControls() {
                // Plus/minus buttons
                document.querySelectorAll(".value-btn").forEach((btn) => {
                    btn.addEventListener("click", (e) => {
                        const target = btn.dataset.target;
                        const delta = parseInt(btn.dataset.delta);
                        const display = document.getElementById(
                            target + "Value",
                        );
                        const min = parseInt(display.dataset.min);
                        const max = parseInt(display.dataset.max);
                        let value = parseInt(display.textContent);

                        value = Math.max(min, Math.min(max, value + delta));
                        display.textContent = value;

                        // Update max values for dependent controls
                        if (target === "edo") {
                            document.getElementById(
                                "scaleNotesValue",
                            ).dataset.max = value;
                            const scaleNotes = parseInt(
                                document.getElementById("scaleNotesValue")
                                    .textContent,
                            );
                            if (scaleNotes > value) {
                                document.getElementById(
                                    "scaleNotesValue",
                                ).textContent = value;
                            }
                        } else if (target === "scaleNotes") {
                            document.getElementById(
                                "scaleRotationValue",
                            ).dataset.max = value - 1;
                            document.getElementById(
                                "chordNotesValue",
                            ).dataset.max = value;
                            const rotation = parseInt(
                                document.getElementById("scaleRotationValue")
                                    .textContent,
                            );
                            if (rotation >= value) {
                                document.getElementById(
                                    "scaleRotationValue",
                                ).textContent = 0;
                            }
                            const chordNotes = parseInt(
                                document.getElementById("chordNotesValue")
                                    .textContent,
                            );
                            if (chordNotes > value) {
                                document.getElementById(
                                    "chordNotesValue",
                                ).textContent = value;
                            }
                        } else if (target === "chordNotes") {
                            document.getElementById(
                                "chordRotationValue",
                            ).dataset.max = value - 1;
                            const rotation = parseInt(
                                document.getElementById("chordRotationValue")
                                    .textContent,
                            );
                            if (rotation >= value) {
                                document.getElementById(
                                    "chordRotationValue",
                                ).textContent = 0;
                            }
                            // Update sequence notes max when chord notes change
                            updateSequenceNotesMax();
                        } else if (target === "sequenceNotes") {
                            // Update rotation max to be notes - 1
                            document.getElementById(
                                "sequenceRotationValue",
                            ).dataset.max = value - 1;
                            const rotation = parseInt(
                                document.getElementById("sequenceRotationValue")
                                    .textContent,
                            );
                            if (rotation >= value) {
                                document.getElementById(
                                    "sequenceRotationValue",
                                ).textContent = 0;
                            }
                        } else if (target === "sequenceOctaves") {
                            // Update sequence notes max based on chord tones × octaves
                            updateSequenceNotesMax();
                        } else if (
                            target === "sequenceBase" ||
                            target === "sequenceRotation"
                        ) {
                            // These sequence controls don't affect other controls
                        }

                        // Real-time playback updates for sequence parameters
                        if (sequenceInterval) {
                            // Tempo changes - update interval timing
                            if (target === "cpm") {
                                updateSequencePlayback();
                            }
                            // Pattern structure changes - regenerate pattern
                            else if (
                                // Mono-specific pattern changes (excluding portamento - that's performance only)
                                (document.getElementById("synthMode").value ===
                                    "mono" &&
                                    false) || // Mono portamento doesn't change pattern structure anymore
                                // Poly-specific pattern changes
                                (document.getElementById("synthMode").value ===
                                    "poly" &&
                                    (target === "rhythmPulses" ||
                                        target === "rhythmRotation" ||
                                        target === "patternSteps"))
                            ) {
                                generateSequencePattern();
                                updateSequenceVisualization();
                                // Also update timing if pattern steps changed
                                if (target === "patternSteps") {
                                    updateSequencePlayback();
                                }
                            }
                            // Portamento changes - just update portamento pattern without reshuffling
                            else if (
                                document.getElementById("synthMode").value ===
                                    "mono" &&
                                (target === "portamentoSteps" ||
                                    target === "portamentoRotation")
                            ) {
                                updatePortamentoPattern();
                                updateSequenceVisualization();
                            }
                            // These parameters take effect on next occurrence (no action needed)
                            // - portamentoTime (mono): applied on next glide
                            // - attackTime/decayTime (poly): applied on next note
                        }

                        // Sync real-time parameters that don't need full tone regeneration
                        if (
                            [
                                "portamentoTime",
                                "attackTime",
                                "decayTime",
                            ].includes(target)
                        ) {
                            appState.set(target, value);
                        }

                        // Only call generateTones for parameters that affect tone generation
                        if (
                            ![
                                "portamentoSteps",
                                "portamentoRotation",
                                "portamentoTime",
                                "attackTime",
                                "decayTime",
                                "cpm",
                            ].includes(target)
                        ) {
                            generateTones();
                        }
                    });
                });

                // Drag functionality
                document
                    .querySelectorAll(".value-display")
                    .forEach((display) => {
                        let isDragging = false;
                        let startY = 0;
                        let startValue = 0;

                        display.addEventListener("mousedown", (e) => {
                            isDragging = true;
                            startY = e.clientY;
                            startValue = parseInt(display.textContent);
                            display.classList.add("dragging");
                            document.body.style.cursor = "ns-resize";
                            e.preventDefault();
                        });

                        document.addEventListener("mousemove", (e) => {
                            if (!isDragging) return;

                            const delta = Math.floor((startY - e.clientY) / 5); // 5 pixels per increment
                            const min = parseInt(display.dataset.min);
                            const max = parseInt(display.dataset.max);
                            const multiplier = e.shiftKey ? 0.1 : 1; // Fine control with shift

                            let value =
                                startValue + Math.floor(delta * multiplier);
                            value = Math.max(min, Math.min(max, value));

                            if (display.textContent !== value.toString()) {
                                display.textContent = value;

                                // Handle dependent values
                                const id = display.id;
                                if (id === "edoValue") {
                                    document.getElementById(
                                        "scaleNotesValue",
                                    ).dataset.max = value;
                                } else if (id === "scaleNotesValue") {
                                    document.getElementById(
                                        "scaleRotationValue",
                                    ).dataset.max = value - 1;
                                    document.getElementById(
                                        "chordNotesValue",
                                    ).dataset.max = value;
                                } else if (id === "chordNotesValue") {
                                    document.getElementById(
                                        "chordRotationValue",
                                    ).dataset.max = value - 1;
                                }

                                // Real-time playback updates during drag
                                if (sequenceInterval) {
                                    if (id === "cpmValue") {
                                        updateSequencePlayback();
                                    } else if (
                                        // Poly pattern changes
                                        document.getElementById("synthMode")
                                            .value === "poly" &&
                                        (id === "rhythmPulsesValue" ||
                                            id === "rhythmRotationValue" ||
                                            id === "patternStepsValue")
                                    ) {
                                        generateSequencePattern();
                                        updateSequenceVisualization();
                                        if (id === "patternStepsValue") {
                                            updateSequencePlayback();
                                        }
                                    }
                                    // Mono portamento changes - just update portamento pattern
                                    else if (
                                        document.getElementById("synthMode")
                                            .value === "mono" &&
                                        (id === "portamentoStepsValue" ||
                                            id === "portamentoRotationValue")
                                    ) {
                                        updatePortamentoPattern();
                                        updateSequenceVisualization();
                                    }
                                }

                                // Sync real-time parameters that don't need full tone regeneration
                                const paramId = display.id.replace("Value", "");
                                if (
                                    [
                                        "portamentoTime",
                                        "attackTime",
                                        "decayTime",
                                    ].includes(paramId)
                                ) {
                                    const newValue = parseInt(
                                        display.textContent,
                                    );
                                    appState.set(paramId, newValue);
                                }

                                // Only call generateTones for parameters that affect tone generation
                                if (
                                    ![
                                        "portamentoSteps",
                                        "portamentoRotation",
                                        "portamentoTime",
                                        "attackTime",
                                        "decayTime",
                                        "cpm",
                                    ].includes(paramId)
                                ) {
                                    generateTones();
                                }
                            }
                        });

                        document.addEventListener("mouseup", () => {
                            if (isDragging) {
                                isDragging = false;
                                display.classList.remove("dragging");
                                document.body.style.cursor = "";
                            }
                        });

                        // Double-click to reset
                        display.addEventListener("dblclick", () => {
                            display.textContent = display.dataset.default;

                            // Sync real-time parameters immediately
                            const paramId = display.id.replace("Value", "");
                            if (
                                [
                                    "portamentoTime",
                                    "attackTime",
                                    "decayTime",
                                ].includes(paramId)
                            ) {
                                appState.set(
                                    paramId,
                                    parseInt(display.textContent),
                                );
                            }

                            generateTones();
                        });
                    });
            }

            // Initialize
            populateMidiDropdown();
            setupValueControls();
            // WebSocket connection removed - everything runs client-side now

            // Initialize mode display
            document
                .getElementById("synthMode")
                .dispatchEvent(new Event("change"));

            // Initialize application with state synchronization
            function initializeApp() {
                // Sync state from DOM
                appState.syncFromDOM();

                // Update pipeline with initial parameters
                pipeline.updateParam("edo", appState.get("edo"));
                pipeline.updateParam("scaleNotes", appState.get("scaleNotes"));
                pipeline.updateParam(
                    "scaleRotation",
                    appState.get("scaleRotation"),
                );
                pipeline.updateParam("chordNotes", appState.get("chordNotes"));
                pipeline.updateParam(
                    "chordRotation",
                    appState.get("chordRotation"),
                );
                pipeline.updateParam("rootFreq", appState.get("rootFreq"));
                pipeline.updateParam(
                    "sequenceNotes",
                    appState.get("sequenceNotes"),
                );
                pipeline.updateParam(
                    "sequenceMethod",
                    appState.get("sequenceMethod"),
                );
                pipeline.updateParam(
                    "sequenceBase",
                    appState.get("sequenceBase"),
                );
                pipeline.updateParam(
                    "sequenceOctaves",
                    appState.get("sequenceOctaves"),
                );
                pipeline.updateParam(
                    "sequenceRotation",
                    appState.get("sequenceRotation"),
                );

                // Initialize reshuffle button visibility
                const sequenceOrder =
                    document.getElementById("sequenceOrder").value;
                const reshuffleControl = document.getElementById(
                    "sequenceShuffleControl",
                );
                if (sequenceOrder === "shuffle") {
                    reshuffleControl.style.display = "block";
                } else {
                    reshuffleControl.style.display = "none";
                }

                // Initialize randomize button visibility based on sequence method
                const sequenceMethod =
                    document.getElementById("sequenceMethod").value;
                const rotationControl = document.getElementById(
                    "sequenceRotationControl",
                );
                const randomizeControl = document.getElementById(
                    "sequenceRandomizeControl",
                );
                if (sequenceMethod === "euclidean") {
                    rotationControl.style.display = "block";
                    randomizeControl.style.display = "none";
                } else if (sequenceMethod === "random") {
                    rotationControl.style.display = "none";
                    randomizeControl.style.display = "block";
                }

                updateTonesDisplay();

                // Generate initial sequence pattern and visualization
                generateSequencePattern();
                updateSequenceVisualization();
            }

            if (document.readyState === "loading") {
                document.addEventListener("DOMContentLoaded", () => {
                    setTimeout(initializeApp, 100);
                });
            } else {
                setTimeout(initializeApp, 100);
            }
        </script>
    </body>
</html>
